<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta charset="utf-8">
  <title>
  spacegaier / AdvancedOgreFramework 
  / source  / AdvancedOgreFramework / rapidxml.hpp
 &mdash; Bitbucket
</title>
  <link rel="icon" type="image/png" href="https://d3oaxc4q5k2d6q.cloudfront.net/m/9e262ba34f96/img/favicon.png">
  <meta id="bb-canon-url" name="bb-canon-url" content="https://bitbucket.org">
  
  
<link rel="stylesheet" href="https://d3oaxc4q5k2d6q.cloudfront.net/m/9e262ba34f96/compressed/css/4dfbc6f0595b.css" type="text/css" />
<link rel="stylesheet" href="https://d3oaxc4q5k2d6q.cloudfront.net/m/9e262ba34f96/compressed/css/f59a383aa1ea.css" type="text/css" />

  <!--[if lt IE 9]><link rel="stylesheet" href="https://d3oaxc4q5k2d6q.cloudfront.net/m/9e262ba34f96/css/aui/aui-ie.css" media="all"><![endif]-->
  <!--[if IE 9]><link rel="stylesheet" href="https://d3oaxc4q5k2d6q.cloudfront.net/m/9e262ba34f96/css/aui/aui-ie9.css" media="all"><![endif]-->
  <!--[if IE]><link rel="stylesheet" href="https://d3oaxc4q5k2d6q.cloudfront.net/m/9e262ba34f96/css/aui-overrides-ie.css" media="all"><![endif]-->
  <meta name="description" content=""/>
  <link rel="search" type="application/opensearchdescription+xml" href="/opensearch.xml" title="Bitbucket" />
  
  <link href="/spacegaier/advancedogreframework/rss" rel="alternate nofollow" type="application/rss+xml" title="RSS feed for AdvancedOgreFramework" />

<script type="text/javascript">var NREUMQ=NREUMQ||[];NREUMQ.push(["mark","firstbyte",new Date().getTime()]);</script></head>
<body class="aui-layout production "
      >
<script type="text/javascript" src="https://d3oaxc4q5k2d6q.cloudfront.net/m/9e262ba34f96/compressed/js/e98deabf8a2e.js"></script>
<div id="page">
  <div id="wrapper">
    
    <header id="header" role="banner">
      
      <nav class="aui-header aui-dropdown2-trigger-group" role="navigation">
        <div class="aui-header-inner">
          <div class="aui-header-primary">
            <h1 class="aui-header-logo aui-header-logo-bitbucket">
              <a href="/" class="aui-nav-imagelink" id="logo-link">
                <span class="aui-header-logo-device">Bitbucket</span>
              </a>
            </h1>
            
              <script id="repo-dropdown-template" type="text/html">
  

[[#hasViewed]]
  <div class="aui-dropdown2-section">
    <strong class="viewed">Recently viewed</strong>
    <ul class="aui-list-truncate">
      [[#viewed]]
        <li class="[[#is_private]]private[[/is_private]][[^is_private]]public[[/is_private]] repository">
          <a href="[[url]]" title="[[owner]]/[[name]]" class=" aui-icon-container">
            <img class="repo-avatar size16" src="[[{avatar}]]" alt="[[owner]]/[[name]] avatar"/>
            [[owner]] / [[name]]
          </a>
        </li>
      [[/viewed]]
    </ul>
  </div>
[[/hasViewed]]
[[#hasUpdated]]
<div class="aui-dropdown2-section">
  <strong class="updated">Recently updated</strong>
  <ul class="aui-list-truncate">
    [[#updated]]
    <li class="[[#is_private]]private[[/is_private]][[^is_private]]public[[/is_private]] repository">
      <a href="[[url]]" title="[[owner]]/[[name]]" class=" aui-icon-container">
        <img class="repo-avatar size16" src="[[{avatar}]]" alt="[[owner]]/[[name]] avatar"/>
        [[owner]] / [[name]]
      </a>
    </li>
    [[/updated]]
  </ul>
</div>
[[/hasUpdated]]

</script>
              <ul role="menu" class="aui-nav">
                
                  <li>
                    <a href="/plans">
                      Pricing &amp; signup
                    </a>
                  </li>
                  <li>
                    <a href="/whats-new">
                      What's new
                    </a>
                  </li>
                
              </ul>
            
          </div>
          <div class="aui-header-secondary">
            
              <ul role="menu" class="aui-nav">
                <li>
                  <form action="/repo/all" method="get" class="aui-quicksearch">
                    <label for="search-query" class="assistive">owner/repository</label>
                    <input  id="search-query" class="search" type="text" placeholder="owner/repository" name="name">
                  </form>
                </li>
                <li>
                  <a class="aui-dropdown2-trigger"aria-controls="header-help-dropdown" aria-owns="header-help-dropdown"
                    aria-haspopup="true" data-container="#header .aui-header-inner" href="#header-help-dropdown">
                    <span class="aui-icon aui-icon-small aui-iconfont-help">Help</span><span class="aui-icon-dropdown"></span>
                  </a>
                  <nav id="header-help-dropdown" class="aui-dropdown2 aui-style-default aui-dropdown2-in-header" aria-hidden="true">
                    <div class="aui-dropdown2-section">
                      <ul>
                        <li>
                          <a href="/whats-new" id="features-link">
                            What's new
                          </a>
                        </li>
                      </ul>
                    </div>
                    <div class="aui-dropdown2-section">
                      <ul>
                        <li><a href="https://confluence.atlassian.com/display/BITBUCKET/bitbucket+Documentation+Home" target="_blank">Documentation</a></li>
                        <li><a href="https://confluence.atlassian.com/display/BITBUCKET/bitbucket+101" target="_blank">Bitbucket 101</a></li>
                        <li><a href="https://confluence.atlassian.com/display/BBKB/Bitbucket+Knowledge+Base+Home" target="_blank">Knowledge base</a></li>
                      </ul>
                    </div>
                    <div class="aui-dropdown2-section">
                      <ul>
                        <li><a href="https://answers.atlassian.com/tags/bitbucket/" target="_blank">Bitbucket on Atlassian Answers</a></li>
                        <li><a href="/support">Support</a></li>
                      </ul>
                    </div>
                  </nav>
                </li>
                
                
                  <li>
                    <a class="aui-button aui-button-primary aui-style" href="/account/signup/">
                      Sign up
                    </a>
                  </li>
                  <li id="user-options">
                    <a href="/account/signin/?next=/spacegaier/advancedogreframework/src/d24a1662021a2ca899990513e45bc2477cbd9339/AdvancedOgreFramework/rapidxml.hpp%3Fat%3Ddefault" class="aui-nav-link login-link">Log in</a>
                  </li>
                
              </ul>
            
          </div>
        </div>
      </nav>
    </header>
      <header id="account-warning" role="banner"
              class="aui-message-banner warning ">
        <div class="center-content">
          <span class="aui-icon aui-icon-warning"></span>
          <span class="message">
            
          </span>
        </div>
      </header>
    
      <header id="aui-message-bar">
        
      </header>
    
    
  <header id="repo-warning" role="banner" class="aui-message-banner warning">
    <div class="center-content">
      <span class="aui-icon aui-icon-warning"></span>
      <span class="message">
      </span>
    </div>
  </header>
  <script id="repo-warning-template" type="text/html">
  




  This repository's ownership is pending transfer to <a href="/[[username]]">[[username]]</a>.
  Visit the <a href="/spacegaier/advancedogreframework/admin/transfer">transfer repository page</a> to view more details.


</script>
  <header id="repo-header" class="subhead row">
    <div class="center-content">
      <div class="repo-summary">
        <a class="repo-avatar-link" href="/spacegaier/advancedogreframework">
          <span class="repo-avatar-container size64" title="spacegaier/AdvancedOgreFramework">
  <img alt="spacegaier/AdvancedOgreFramework" src="https://d3oaxc4q5k2d6q.cloudfront.net/m/9e262ba34f96/img/language-avatars/c_plus_plus_64.png">
</span>

          
        </a>
        <h1><a class="repo-link" href="/spacegaier/advancedogreframework">AdvancedOgreFramework</a></h1>
        <ul class="repo-metadata clearfix">
          <li>
            <a class="user" href="/spacegaier">
              <span class="icon user">User icon</span>
              <span>spacegaier</span>
            </a>
          </li>
          
          
          <li class="social">
            <a class="follow" id="repo-follow"
               rel="nofollow"
               href="/spacegaier/advancedogreframework/follow">
              <span class="icon follow">Follow icon</span>
              <span class="text">Follow</span>
            </a>
          </li>
          
        </ul>
      </div>
      <div id="repo-toolbar" class="bb-toolbar">
        
        <div class="aui-buttons">
          <a id="repo-clone-button" class="aui-button aui-style" href="https://bitbucket.org/spacegaier/advancedogreframework">
            <span class="icon clone">Clone icon</span>
            <span>Clone</span>
            <span class="aui-icon-dropdown"></span>
          </a>
          <a id="fork-button" class="aui-button aui-style"
             href="/spacegaier/advancedogreframework/fork">
            <span class="icon fork">Fork icon</span>
            <span>Fork</span>
          </a>
        </div>
        <div class="aui-buttons">
          <a id="compare-button" class="aui-button aui-style"
             href="/spacegaier/advancedogreframework/compare">
            <span class="icon compare">Compare icon</span>
            <span>Compare</span>
          </a>
          <a id="pull-request-button" class="aui-button aui-style"
             href="/spacegaier/advancedogreframework/pull-request/new">
            <span class="icon pull-request">Pull request icon</span>
            <span>Pull request</span>
          </a>
        </div>
        
        

<div id="repo-clone-dialog" class="clone-dialog hidden">
  
<div class="clone-url">
  <div class="aui-buttons">
    <a href="https://bitbucket.org/spacegaier/advancedogreframework"
       class="aui-button aui-style aui-dropdown2-trigger" aria-haspopup="true"
       aria-owns="clone-url-dropdown-header">
      <span class="dropdown-text">HTTPS</span>
    </a>
    <div id="clone-url-dropdown-header" class="aui-dropdown2 aui-style-default">
      <ul class="aui-list-truncate">
        <li>
          <a href="https://bitbucket.org/spacegaier/advancedogreframework"
            
              data-command="hg clone https://bitbucket.org/spacegaier/advancedogreframework"
            
            class="item-link https">HTTPS
          </a>
        </li>
        <li>
          <a href="ssh://hg@bitbucket.org/spacegaier/advancedogreframework"
            
              data-command="hg clone ssh://hg@bitbucket.org/spacegaier/advancedogreframework"
            
            class="item-link ssh">SSH
          </a>
        </li>
      </ul>
    </div>
    <input type="text" readonly="readonly" value="hg clone https://bitbucket.org/spacegaier/advancedogreframework">
  </div>
  
  <p>Need help cloning? Visit
     <a href="https://confluence.atlassian.com/x/cgozDQ" target="_blank">Bitbucket 101</a>.</p>
  
</div>


  
  
  

<div class="clone-in-sourcetree"
  data-https-url="https://bitbucket.org/spacegaier/advancedogreframework"
  data-ssh-url="ssh://hg@bitbucket.org/spacegaier/advancedogreframework">
  <p><button class="aui-button aui-style aui-button-primary">Clone in SourceTree</button></p>

  <p>
    
      
        <a href="http://www.sourcetreeapp.com" target="_blank">SourceTree</a>
        is a free Mac client by Atlassian for Git, Mercurial, and Subversion.
      
    
  </p>
</div>

  
</div>

      </div>
    </div>
    <div class="clearfix"></div>
  </header>
  <nav id="repo-tabs" class="aui-navgroup aui-navgroup-horizontal aui-navgroup-horizontal-roomy">
    <div class="aui-navgroup-inner">
      <div class="aui-navgroup-primary">
        <ul class="aui-nav">
          
            <li>
              <a href="/spacegaier/advancedogreframework/overview" id="repo-overview-link">Overview</a>
            </li>
          
          
            <li class="aui-nav-selected">
              <a href="/spacegaier/advancedogreframework/src" id="repo-source-link">Source</a>
            </li>
          
          
            <li>
              <a href="/spacegaier/advancedogreframework/commits" id="repo-commits-link">
                Commits
              </a>
            </li>
          
          
            <li>
              <a href="/spacegaier/advancedogreframework/pull-requests" id="repo-pullrequests-link">
                Pull requests
                
                  
                
              </a>
            </li>
          
          
            
          
            <li id="issues-tab" class="
              
                hidden
              
            ">
              <a href="/spacegaier/advancedogreframework/issues?status=new&amp;status=open" id="repo-issues-link">
                Issues
                
                  
                
              </a>
            </li>
            <li id="wiki-tab" class="
                
                  
                    hidden
                  
                
              ">
              <a href="/spacegaier/advancedogreframework/wiki" id="repo-wiki-link">Wiki</a>
            </li>
          
            <li>
            <a href="/spacegaier/advancedogreframework/downloads" id="repo-downloads-link">
              Downloads
              
                
              
            </a>
            </li>
          
        </ul>
      </div>
      <div class="aui-navgroup-secondary">
        <ul class="aui-nav">
          
        </ul>
      </div>
    </div>
  </nav>

    <div id="content" role="main">
      
  <div id="repo-content">
    
  <div id="source-container">
    



<header id="source-path">
  
  <div class="labels labels-csv">
    
      <div class="aui-buttons">
        <button data-branches-tags-url="/api/1.0/repositories/spacegaier/advancedogreframework/branches-tags"
                class="aui-button aui-style branch-dialog-trigger" title="default">
          
            
              <span class="branch icon">Branch</span>
            
            <span class="name">default</span>
          
          <span class="aui-icon-dropdown"></span>
        </button>
      </div>
    
  </div>
  
  
    <div class="view-switcher">
      <div class="aui-buttons">
        
          <a href="/spacegaier/advancedogreframework/src/d24a1662021a/AdvancedOgreFramework/rapidxml.hpp?at=default"
             class="aui-button aui-style pjax-trigger" aria-pressed="true">
            Source
          </a>
          <a href="/spacegaier/advancedogreframework/diff/AdvancedOgreFramework/rapidxml.hpp?diff2=d24a1662021a&at=default"
             class="aui-button aui-style pjax-trigger"
             title="Diff to previous change">
            Diff
          </a>
          <a href="/spacegaier/advancedogreframework/history-node/d24a1662021a/AdvancedOgreFramework/rapidxml.hpp?at=default"
             class="aui-button aui-style pjax-trigger">
            History
          </a>
        
      </div>
    </div>
  
  <h1>
    <a href="/spacegaier/advancedogreframework/src/d24a1662021a?at=default"
       class="pjax-trigger" title="[u&#39;AdvancedOgreFramework&#39;, u&#39;rapidxml.hpp&#39;]">AdvancedOgreFramework</a> /
    
      
        
          
            <a href="/spacegaier/advancedogreframework/src/d24a1662021a/AdvancedOgreFramework?at=default"
               class="pjax-trigger">AdvancedOgreFramework</a> /
          
        
      
    
      
        
          <span>rapidxml.hpp</span>
        
      
    
  </h1>
  
    
    
  
  <div class="clearfix"></div>
</header>


  
    <div id="source-view">
      <div class="toolbar">
        <div class="primary">
          <div class="aui-buttons">
            
              <button id="file-history-trigger" class="aui-button aui-style changeset-info"
                      data-changeset="d24a1662021a2ca899990513e45bc2477cbd9339"
                      data-path="AdvancedOgreFramework/rapidxml.hpp"
                      data-current="d24a1662021a2ca899990513e45bc2477cbd9339">
                
                   

<img class="avatar avatar16" src="https://secure.gravatar.com/avatar/5fe8ca7a0588f2ebe5eacda338ee4d45?d=https%3A%2F%2Fd3oaxc4q5k2d6q.cloudfront.net%2Fm%2F9e262ba34f96%2Fimg%2Fdefault_avatar%2F16%2Fuser_blue.png&amp;s=16" alt="Philip Allgaier avatar" />
<span class="changeset-hash">d24a166</span>
<time datetime="2013-02-10T23:54:06+00:00" class="timestamp"></time>
<span class="aui-icon-dropdown"></span>

                
              </button>
            
          </div>
        </div>
          <div class="secondary">
            
              <div class="aui-buttons">
                <a href="/spacegaier/advancedogreframework/annotate/d24a1662021a2ca899990513e45bc2477cbd9339/AdvancedOgreFramework/rapidxml.hpp?at=default"
                   class="aui-button aui-style pjax-trigger">Blame</a>
              </div>
            
            <div class="aui-buttons">
              
              <a href="/spacegaier/advancedogreframework/full-commit/d24a1662021a/AdvancedOgreFramework/rapidxml.hpp" class="aui-button aui-style"
                 title="View full commit d24a166">Full commit</a>
              
                
                <a id="embed-link" href="https://bitbucket.org/spacegaier/advancedogreframework/src/d24a1662021a2ca899990513e45bc2477cbd9339/AdvancedOgreFramework/rapidxml.hpp?embed=t"
                   class="aui-button aui-style">Embed</a>
              
              <a href="/spacegaier/advancedogreframework/raw/d24a1662021a2ca899990513e45bc2477cbd9339/AdvancedOgreFramework/rapidxml.hpp"
                 class="aui-button aui-style">Raw</a>
            </div>
          </div>
        <div class="clearfix"></div>
      </div>
    </div>

    
      
        
          <div class="file-source">
            <table class="highlighttable">
<tr><td class="linenos"><div class="linenodiv"><pre>
<a href="#cl-1">1</a>
<a href="#cl-2">2</a>
<a href="#cl-3">3</a>
<a href="#cl-4">4</a>
<a href="#cl-5">5</a>
<a href="#cl-6">6</a>
<a href="#cl-7">7</a>
<a href="#cl-8">8</a>
<a href="#cl-9">9</a>
<a href="#cl-10">10</a>
<a href="#cl-11">11</a>
<a href="#cl-12">12</a>
<a href="#cl-13">13</a>
<a href="#cl-14">14</a>
<a href="#cl-15">15</a>
<a href="#cl-16">16</a>
<a href="#cl-17">17</a>
<a href="#cl-18">18</a>
<a href="#cl-19">19</a>
<a href="#cl-20">20</a>
<a href="#cl-21">21</a>
<a href="#cl-22">22</a>
<a href="#cl-23">23</a>
<a href="#cl-24">24</a>
<a href="#cl-25">25</a>
<a href="#cl-26">26</a>
<a href="#cl-27">27</a>
<a href="#cl-28">28</a>
<a href="#cl-29">29</a>
<a href="#cl-30">30</a>
<a href="#cl-31">31</a>
<a href="#cl-32">32</a>
<a href="#cl-33">33</a>
<a href="#cl-34">34</a>
<a href="#cl-35">35</a>
<a href="#cl-36">36</a>
<a href="#cl-37">37</a>
<a href="#cl-38">38</a>
<a href="#cl-39">39</a>
<a href="#cl-40">40</a>
<a href="#cl-41">41</a>
<a href="#cl-42">42</a>
<a href="#cl-43">43</a>
<a href="#cl-44">44</a>
<a href="#cl-45">45</a>
<a href="#cl-46">46</a>
<a href="#cl-47">47</a>
<a href="#cl-48">48</a>
<a href="#cl-49">49</a>
<a href="#cl-50">50</a>
<a href="#cl-51">51</a>
<a href="#cl-52">52</a>
<a href="#cl-53">53</a>
<a href="#cl-54">54</a>
<a href="#cl-55">55</a>
<a href="#cl-56">56</a>
<a href="#cl-57">57</a>
<a href="#cl-58">58</a>
<a href="#cl-59">59</a>
<a href="#cl-60">60</a>
<a href="#cl-61">61</a>
<a href="#cl-62">62</a>
<a href="#cl-63">63</a>
<a href="#cl-64">64</a>
<a href="#cl-65">65</a>
<a href="#cl-66">66</a>
<a href="#cl-67">67</a>
<a href="#cl-68">68</a>
<a href="#cl-69">69</a>
<a href="#cl-70">70</a>
<a href="#cl-71">71</a>
<a href="#cl-72">72</a>
<a href="#cl-73">73</a>
<a href="#cl-74">74</a>
<a href="#cl-75">75</a>
<a href="#cl-76">76</a>
<a href="#cl-77">77</a>
<a href="#cl-78">78</a>
<a href="#cl-79">79</a>
<a href="#cl-80">80</a>
<a href="#cl-81">81</a>
<a href="#cl-82">82</a>
<a href="#cl-83">83</a>
<a href="#cl-84">84</a>
<a href="#cl-85">85</a>
<a href="#cl-86">86</a>
<a href="#cl-87">87</a>
<a href="#cl-88">88</a>
<a href="#cl-89">89</a>
<a href="#cl-90">90</a>
<a href="#cl-91">91</a>
<a href="#cl-92">92</a>
<a href="#cl-93">93</a>
<a href="#cl-94">94</a>
<a href="#cl-95">95</a>
<a href="#cl-96">96</a>
<a href="#cl-97">97</a>
<a href="#cl-98">98</a>
<a href="#cl-99">99</a>
<a href="#cl-100">100</a>
<a href="#cl-101">101</a>
<a href="#cl-102">102</a>
<a href="#cl-103">103</a>
<a href="#cl-104">104</a>
<a href="#cl-105">105</a>
<a href="#cl-106">106</a>
<a href="#cl-107">107</a>
<a href="#cl-108">108</a>
<a href="#cl-109">109</a>
<a href="#cl-110">110</a>
<a href="#cl-111">111</a>
<a href="#cl-112">112</a>
<a href="#cl-113">113</a>
<a href="#cl-114">114</a>
<a href="#cl-115">115</a>
<a href="#cl-116">116</a>
<a href="#cl-117">117</a>
<a href="#cl-118">118</a>
<a href="#cl-119">119</a>
<a href="#cl-120">120</a>
<a href="#cl-121">121</a>
<a href="#cl-122">122</a>
<a href="#cl-123">123</a>
<a href="#cl-124">124</a>
<a href="#cl-125">125</a>
<a href="#cl-126">126</a>
<a href="#cl-127">127</a>
<a href="#cl-128">128</a>
<a href="#cl-129">129</a>
<a href="#cl-130">130</a>
<a href="#cl-131">131</a>
<a href="#cl-132">132</a>
<a href="#cl-133">133</a>
<a href="#cl-134">134</a>
<a href="#cl-135">135</a>
<a href="#cl-136">136</a>
<a href="#cl-137">137</a>
<a href="#cl-138">138</a>
<a href="#cl-139">139</a>
<a href="#cl-140">140</a>
<a href="#cl-141">141</a>
<a href="#cl-142">142</a>
<a href="#cl-143">143</a>
<a href="#cl-144">144</a>
<a href="#cl-145">145</a>
<a href="#cl-146">146</a>
<a href="#cl-147">147</a>
<a href="#cl-148">148</a>
<a href="#cl-149">149</a>
<a href="#cl-150">150</a>
<a href="#cl-151">151</a>
<a href="#cl-152">152</a>
<a href="#cl-153">153</a>
<a href="#cl-154">154</a>
<a href="#cl-155">155</a>
<a href="#cl-156">156</a>
<a href="#cl-157">157</a>
<a href="#cl-158">158</a>
<a href="#cl-159">159</a>
<a href="#cl-160">160</a>
<a href="#cl-161">161</a>
<a href="#cl-162">162</a>
<a href="#cl-163">163</a>
<a href="#cl-164">164</a>
<a href="#cl-165">165</a>
<a href="#cl-166">166</a>
<a href="#cl-167">167</a>
<a href="#cl-168">168</a>
<a href="#cl-169">169</a>
<a href="#cl-170">170</a>
<a href="#cl-171">171</a>
<a href="#cl-172">172</a>
<a href="#cl-173">173</a>
<a href="#cl-174">174</a>
<a href="#cl-175">175</a>
<a href="#cl-176">176</a>
<a href="#cl-177">177</a>
<a href="#cl-178">178</a>
<a href="#cl-179">179</a>
<a href="#cl-180">180</a>
<a href="#cl-181">181</a>
<a href="#cl-182">182</a>
<a href="#cl-183">183</a>
<a href="#cl-184">184</a>
<a href="#cl-185">185</a>
<a href="#cl-186">186</a>
<a href="#cl-187">187</a>
<a href="#cl-188">188</a>
<a href="#cl-189">189</a>
<a href="#cl-190">190</a>
<a href="#cl-191">191</a>
<a href="#cl-192">192</a>
<a href="#cl-193">193</a>
<a href="#cl-194">194</a>
<a href="#cl-195">195</a>
<a href="#cl-196">196</a>
<a href="#cl-197">197</a>
<a href="#cl-198">198</a>
<a href="#cl-199">199</a>
<a href="#cl-200">200</a>
<a href="#cl-201">201</a>
<a href="#cl-202">202</a>
<a href="#cl-203">203</a>
<a href="#cl-204">204</a>
<a href="#cl-205">205</a>
<a href="#cl-206">206</a>
<a href="#cl-207">207</a>
<a href="#cl-208">208</a>
<a href="#cl-209">209</a>
<a href="#cl-210">210</a>
<a href="#cl-211">211</a>
<a href="#cl-212">212</a>
<a href="#cl-213">213</a>
<a href="#cl-214">214</a>
<a href="#cl-215">215</a>
<a href="#cl-216">216</a>
<a href="#cl-217">217</a>
<a href="#cl-218">218</a>
<a href="#cl-219">219</a>
<a href="#cl-220">220</a>
<a href="#cl-221">221</a>
<a href="#cl-222">222</a>
<a href="#cl-223">223</a>
<a href="#cl-224">224</a>
<a href="#cl-225">225</a>
<a href="#cl-226">226</a>
<a href="#cl-227">227</a>
<a href="#cl-228">228</a>
<a href="#cl-229">229</a>
<a href="#cl-230">230</a>
<a href="#cl-231">231</a>
<a href="#cl-232">232</a>
<a href="#cl-233">233</a>
<a href="#cl-234">234</a>
<a href="#cl-235">235</a>
<a href="#cl-236">236</a>
<a href="#cl-237">237</a>
<a href="#cl-238">238</a>
<a href="#cl-239">239</a>
<a href="#cl-240">240</a>
<a href="#cl-241">241</a>
<a href="#cl-242">242</a>
<a href="#cl-243">243</a>
<a href="#cl-244">244</a>
<a href="#cl-245">245</a>
<a href="#cl-246">246</a>
<a href="#cl-247">247</a>
<a href="#cl-248">248</a>
<a href="#cl-249">249</a>
<a href="#cl-250">250</a>
<a href="#cl-251">251</a>
<a href="#cl-252">252</a>
<a href="#cl-253">253</a>
<a href="#cl-254">254</a>
<a href="#cl-255">255</a>
<a href="#cl-256">256</a>
<a href="#cl-257">257</a>
<a href="#cl-258">258</a>
<a href="#cl-259">259</a>
<a href="#cl-260">260</a>
<a href="#cl-261">261</a>
<a href="#cl-262">262</a>
<a href="#cl-263">263</a>
<a href="#cl-264">264</a>
<a href="#cl-265">265</a>
<a href="#cl-266">266</a>
<a href="#cl-267">267</a>
<a href="#cl-268">268</a>
<a href="#cl-269">269</a>
<a href="#cl-270">270</a>
<a href="#cl-271">271</a>
<a href="#cl-272">272</a>
<a href="#cl-273">273</a>
<a href="#cl-274">274</a>
<a href="#cl-275">275</a>
<a href="#cl-276">276</a>
<a href="#cl-277">277</a>
<a href="#cl-278">278</a>
<a href="#cl-279">279</a>
<a href="#cl-280">280</a>
<a href="#cl-281">281</a>
<a href="#cl-282">282</a>
<a href="#cl-283">283</a>
<a href="#cl-284">284</a>
<a href="#cl-285">285</a>
<a href="#cl-286">286</a>
<a href="#cl-287">287</a>
<a href="#cl-288">288</a>
<a href="#cl-289">289</a>
<a href="#cl-290">290</a>
<a href="#cl-291">291</a>
<a href="#cl-292">292</a>
<a href="#cl-293">293</a>
<a href="#cl-294">294</a>
<a href="#cl-295">295</a>
<a href="#cl-296">296</a>
<a href="#cl-297">297</a>
<a href="#cl-298">298</a>
<a href="#cl-299">299</a>
<a href="#cl-300">300</a>
<a href="#cl-301">301</a>
<a href="#cl-302">302</a>
<a href="#cl-303">303</a>
<a href="#cl-304">304</a>
<a href="#cl-305">305</a>
<a href="#cl-306">306</a>
<a href="#cl-307">307</a>
<a href="#cl-308">308</a>
<a href="#cl-309">309</a>
<a href="#cl-310">310</a>
<a href="#cl-311">311</a>
<a href="#cl-312">312</a>
<a href="#cl-313">313</a>
<a href="#cl-314">314</a>
<a href="#cl-315">315</a>
<a href="#cl-316">316</a>
<a href="#cl-317">317</a>
<a href="#cl-318">318</a>
<a href="#cl-319">319</a>
<a href="#cl-320">320</a>
<a href="#cl-321">321</a>
<a href="#cl-322">322</a>
<a href="#cl-323">323</a>
<a href="#cl-324">324</a>
<a href="#cl-325">325</a>
<a href="#cl-326">326</a>
<a href="#cl-327">327</a>
<a href="#cl-328">328</a>
<a href="#cl-329">329</a>
<a href="#cl-330">330</a>
<a href="#cl-331">331</a>
<a href="#cl-332">332</a>
<a href="#cl-333">333</a>
<a href="#cl-334">334</a>
<a href="#cl-335">335</a>
<a href="#cl-336">336</a>
<a href="#cl-337">337</a>
<a href="#cl-338">338</a>
<a href="#cl-339">339</a>
<a href="#cl-340">340</a>
<a href="#cl-341">341</a>
<a href="#cl-342">342</a>
<a href="#cl-343">343</a>
<a href="#cl-344">344</a>
<a href="#cl-345">345</a>
<a href="#cl-346">346</a>
<a href="#cl-347">347</a>
<a href="#cl-348">348</a>
<a href="#cl-349">349</a>
<a href="#cl-350">350</a>
<a href="#cl-351">351</a>
<a href="#cl-352">352</a>
<a href="#cl-353">353</a>
<a href="#cl-354">354</a>
<a href="#cl-355">355</a>
<a href="#cl-356">356</a>
<a href="#cl-357">357</a>
<a href="#cl-358">358</a>
<a href="#cl-359">359</a>
<a href="#cl-360">360</a>
<a href="#cl-361">361</a>
<a href="#cl-362">362</a>
<a href="#cl-363">363</a>
<a href="#cl-364">364</a>
<a href="#cl-365">365</a>
<a href="#cl-366">366</a>
<a href="#cl-367">367</a>
<a href="#cl-368">368</a>
<a href="#cl-369">369</a>
<a href="#cl-370">370</a>
<a href="#cl-371">371</a>
<a href="#cl-372">372</a>
<a href="#cl-373">373</a>
<a href="#cl-374">374</a>
<a href="#cl-375">375</a>
<a href="#cl-376">376</a>
<a href="#cl-377">377</a>
<a href="#cl-378">378</a>
<a href="#cl-379">379</a>
<a href="#cl-380">380</a>
<a href="#cl-381">381</a>
<a href="#cl-382">382</a>
<a href="#cl-383">383</a>
<a href="#cl-384">384</a>
<a href="#cl-385">385</a>
<a href="#cl-386">386</a>
<a href="#cl-387">387</a>
<a href="#cl-388">388</a>
<a href="#cl-389">389</a>
<a href="#cl-390">390</a>
<a href="#cl-391">391</a>
<a href="#cl-392">392</a>
<a href="#cl-393">393</a>
<a href="#cl-394">394</a>
<a href="#cl-395">395</a>
<a href="#cl-396">396</a>
<a href="#cl-397">397</a>
<a href="#cl-398">398</a>
<a href="#cl-399">399</a>
<a href="#cl-400">400</a>
<a href="#cl-401">401</a>
<a href="#cl-402">402</a>
<a href="#cl-403">403</a>
<a href="#cl-404">404</a>
<a href="#cl-405">405</a>
<a href="#cl-406">406</a>
<a href="#cl-407">407</a>
<a href="#cl-408">408</a>
<a href="#cl-409">409</a>
<a href="#cl-410">410</a>
<a href="#cl-411">411</a>
<a href="#cl-412">412</a>
<a href="#cl-413">413</a>
<a href="#cl-414">414</a>
<a href="#cl-415">415</a>
<a href="#cl-416">416</a>
<a href="#cl-417">417</a>
<a href="#cl-418">418</a>
<a href="#cl-419">419</a>
<a href="#cl-420">420</a>
<a href="#cl-421">421</a>
<a href="#cl-422">422</a>
<a href="#cl-423">423</a>
<a href="#cl-424">424</a>
<a href="#cl-425">425</a>
<a href="#cl-426">426</a>
<a href="#cl-427">427</a>
<a href="#cl-428">428</a>
<a href="#cl-429">429</a>
<a href="#cl-430">430</a>
<a href="#cl-431">431</a>
<a href="#cl-432">432</a>
<a href="#cl-433">433</a>
<a href="#cl-434">434</a>
<a href="#cl-435">435</a>
<a href="#cl-436">436</a>
<a href="#cl-437">437</a>
<a href="#cl-438">438</a>
<a href="#cl-439">439</a>
<a href="#cl-440">440</a>
<a href="#cl-441">441</a>
<a href="#cl-442">442</a>
<a href="#cl-443">443</a>
<a href="#cl-444">444</a>
<a href="#cl-445">445</a>
<a href="#cl-446">446</a>
<a href="#cl-447">447</a>
<a href="#cl-448">448</a>
<a href="#cl-449">449</a>
<a href="#cl-450">450</a>
<a href="#cl-451">451</a>
<a href="#cl-452">452</a>
<a href="#cl-453">453</a>
<a href="#cl-454">454</a>
<a href="#cl-455">455</a>
<a href="#cl-456">456</a>
<a href="#cl-457">457</a>
<a href="#cl-458">458</a>
<a href="#cl-459">459</a>
<a href="#cl-460">460</a>
<a href="#cl-461">461</a>
<a href="#cl-462">462</a>
<a href="#cl-463">463</a>
<a href="#cl-464">464</a>
<a href="#cl-465">465</a>
<a href="#cl-466">466</a>
<a href="#cl-467">467</a>
<a href="#cl-468">468</a>
<a href="#cl-469">469</a>
<a href="#cl-470">470</a>
<a href="#cl-471">471</a>
<a href="#cl-472">472</a>
<a href="#cl-473">473</a>
<a href="#cl-474">474</a>
<a href="#cl-475">475</a>
<a href="#cl-476">476</a>
<a href="#cl-477">477</a>
<a href="#cl-478">478</a>
<a href="#cl-479">479</a>
<a href="#cl-480">480</a>
<a href="#cl-481">481</a>
<a href="#cl-482">482</a>
<a href="#cl-483">483</a>
<a href="#cl-484">484</a>
<a href="#cl-485">485</a>
<a href="#cl-486">486</a>
<a href="#cl-487">487</a>
<a href="#cl-488">488</a>
<a href="#cl-489">489</a>
<a href="#cl-490">490</a>
<a href="#cl-491">491</a>
<a href="#cl-492">492</a>
<a href="#cl-493">493</a>
<a href="#cl-494">494</a>
<a href="#cl-495">495</a>
<a href="#cl-496">496</a>
<a href="#cl-497">497</a>
<a href="#cl-498">498</a>
<a href="#cl-499">499</a>
<a href="#cl-500">500</a>
<a href="#cl-501">501</a>
<a href="#cl-502">502</a>
<a href="#cl-503">503</a>
<a href="#cl-504">504</a>
<a href="#cl-505">505</a>
<a href="#cl-506">506</a>
<a href="#cl-507">507</a>
<a href="#cl-508">508</a>
<a href="#cl-509">509</a>
<a href="#cl-510">510</a>
<a href="#cl-511">511</a>
<a href="#cl-512">512</a>
<a href="#cl-513">513</a>
<a href="#cl-514">514</a>
<a href="#cl-515">515</a>
<a href="#cl-516">516</a>
<a href="#cl-517">517</a>
<a href="#cl-518">518</a>
<a href="#cl-519">519</a>
<a href="#cl-520">520</a>
<a href="#cl-521">521</a>
<a href="#cl-522">522</a>
<a href="#cl-523">523</a>
<a href="#cl-524">524</a>
<a href="#cl-525">525</a>
<a href="#cl-526">526</a>
<a href="#cl-527">527</a>
<a href="#cl-528">528</a>
<a href="#cl-529">529</a>
<a href="#cl-530">530</a>
<a href="#cl-531">531</a>
<a href="#cl-532">532</a>
<a href="#cl-533">533</a>
<a href="#cl-534">534</a>
<a href="#cl-535">535</a>
<a href="#cl-536">536</a>
<a href="#cl-537">537</a>
<a href="#cl-538">538</a>
<a href="#cl-539">539</a>
<a href="#cl-540">540</a>
<a href="#cl-541">541</a>
<a href="#cl-542">542</a>
<a href="#cl-543">543</a>
<a href="#cl-544">544</a>
<a href="#cl-545">545</a>
<a href="#cl-546">546</a>
<a href="#cl-547">547</a>
<a href="#cl-548">548</a>
<a href="#cl-549">549</a>
<a href="#cl-550">550</a>
<a href="#cl-551">551</a>
<a href="#cl-552">552</a>
<a href="#cl-553">553</a>
<a href="#cl-554">554</a>
<a href="#cl-555">555</a>
<a href="#cl-556">556</a>
<a href="#cl-557">557</a>
<a href="#cl-558">558</a>
<a href="#cl-559">559</a>
<a href="#cl-560">560</a>
<a href="#cl-561">561</a>
<a href="#cl-562">562</a>
<a href="#cl-563">563</a>
<a href="#cl-564">564</a>
<a href="#cl-565">565</a>
<a href="#cl-566">566</a>
<a href="#cl-567">567</a>
<a href="#cl-568">568</a>
<a href="#cl-569">569</a>
<a href="#cl-570">570</a>
<a href="#cl-571">571</a>
<a href="#cl-572">572</a>
<a href="#cl-573">573</a>
<a href="#cl-574">574</a>
<a href="#cl-575">575</a>
<a href="#cl-576">576</a>
<a href="#cl-577">577</a>
<a href="#cl-578">578</a>
<a href="#cl-579">579</a>
<a href="#cl-580">580</a>
<a href="#cl-581">581</a>
<a href="#cl-582">582</a>
<a href="#cl-583">583</a>
<a href="#cl-584">584</a>
<a href="#cl-585">585</a>
<a href="#cl-586">586</a>
<a href="#cl-587">587</a>
<a href="#cl-588">588</a>
<a href="#cl-589">589</a>
<a href="#cl-590">590</a>
<a href="#cl-591">591</a>
<a href="#cl-592">592</a>
<a href="#cl-593">593</a>
<a href="#cl-594">594</a>
<a href="#cl-595">595</a>
<a href="#cl-596">596</a>
<a href="#cl-597">597</a>
<a href="#cl-598">598</a>
<a href="#cl-599">599</a>
<a href="#cl-600">600</a>
<a href="#cl-601">601</a>
<a href="#cl-602">602</a>
<a href="#cl-603">603</a>
<a href="#cl-604">604</a>
<a href="#cl-605">605</a>
<a href="#cl-606">606</a>
<a href="#cl-607">607</a>
<a href="#cl-608">608</a>
<a href="#cl-609">609</a>
<a href="#cl-610">610</a>
<a href="#cl-611">611</a>
<a href="#cl-612">612</a>
<a href="#cl-613">613</a>
<a href="#cl-614">614</a>
<a href="#cl-615">615</a>
<a href="#cl-616">616</a>
<a href="#cl-617">617</a>
<a href="#cl-618">618</a>
<a href="#cl-619">619</a>
<a href="#cl-620">620</a>
<a href="#cl-621">621</a>
<a href="#cl-622">622</a>
<a href="#cl-623">623</a>
<a href="#cl-624">624</a>
<a href="#cl-625">625</a>
<a href="#cl-626">626</a>
<a href="#cl-627">627</a>
<a href="#cl-628">628</a>
<a href="#cl-629">629</a>
<a href="#cl-630">630</a>
<a href="#cl-631">631</a>
<a href="#cl-632">632</a>
<a href="#cl-633">633</a>
<a href="#cl-634">634</a>
<a href="#cl-635">635</a>
<a href="#cl-636">636</a>
<a href="#cl-637">637</a>
<a href="#cl-638">638</a>
<a href="#cl-639">639</a>
<a href="#cl-640">640</a>
<a href="#cl-641">641</a>
<a href="#cl-642">642</a>
<a href="#cl-643">643</a>
<a href="#cl-644">644</a>
<a href="#cl-645">645</a>
<a href="#cl-646">646</a>
<a href="#cl-647">647</a>
<a href="#cl-648">648</a>
<a href="#cl-649">649</a>
<a href="#cl-650">650</a>
<a href="#cl-651">651</a>
<a href="#cl-652">652</a>
<a href="#cl-653">653</a>
<a href="#cl-654">654</a>
<a href="#cl-655">655</a>
<a href="#cl-656">656</a>
<a href="#cl-657">657</a>
<a href="#cl-658">658</a>
<a href="#cl-659">659</a>
<a href="#cl-660">660</a>
<a href="#cl-661">661</a>
<a href="#cl-662">662</a>
<a href="#cl-663">663</a>
<a href="#cl-664">664</a>
<a href="#cl-665">665</a>
<a href="#cl-666">666</a>
<a href="#cl-667">667</a>
<a href="#cl-668">668</a>
<a href="#cl-669">669</a>
<a href="#cl-670">670</a>
<a href="#cl-671">671</a>
<a href="#cl-672">672</a>
<a href="#cl-673">673</a>
<a href="#cl-674">674</a>
<a href="#cl-675">675</a>
<a href="#cl-676">676</a>
<a href="#cl-677">677</a>
<a href="#cl-678">678</a>
<a href="#cl-679">679</a>
<a href="#cl-680">680</a>
<a href="#cl-681">681</a>
<a href="#cl-682">682</a>
<a href="#cl-683">683</a>
<a href="#cl-684">684</a>
<a href="#cl-685">685</a>
<a href="#cl-686">686</a>
<a href="#cl-687">687</a>
<a href="#cl-688">688</a>
<a href="#cl-689">689</a>
<a href="#cl-690">690</a>
<a href="#cl-691">691</a>
<a href="#cl-692">692</a>
<a href="#cl-693">693</a>
<a href="#cl-694">694</a>
<a href="#cl-695">695</a>
<a href="#cl-696">696</a>
<a href="#cl-697">697</a>
<a href="#cl-698">698</a>
<a href="#cl-699">699</a>
<a href="#cl-700">700</a>
<a href="#cl-701">701</a>
<a href="#cl-702">702</a>
<a href="#cl-703">703</a>
<a href="#cl-704">704</a>
<a href="#cl-705">705</a>
<a href="#cl-706">706</a>
<a href="#cl-707">707</a>
<a href="#cl-708">708</a>
<a href="#cl-709">709</a>
<a href="#cl-710">710</a>
<a href="#cl-711">711</a>
<a href="#cl-712">712</a>
<a href="#cl-713">713</a>
<a href="#cl-714">714</a>
<a href="#cl-715">715</a>
<a href="#cl-716">716</a>
<a href="#cl-717">717</a>
<a href="#cl-718">718</a>
<a href="#cl-719">719</a>
<a href="#cl-720">720</a>
<a href="#cl-721">721</a>
<a href="#cl-722">722</a>
<a href="#cl-723">723</a>
<a href="#cl-724">724</a>
<a href="#cl-725">725</a>
<a href="#cl-726">726</a>
<a href="#cl-727">727</a>
<a href="#cl-728">728</a>
<a href="#cl-729">729</a>
<a href="#cl-730">730</a>
<a href="#cl-731">731</a>
<a href="#cl-732">732</a>
<a href="#cl-733">733</a>
<a href="#cl-734">734</a>
<a href="#cl-735">735</a>
<a href="#cl-736">736</a>
<a href="#cl-737">737</a>
<a href="#cl-738">738</a>
<a href="#cl-739">739</a>
<a href="#cl-740">740</a>
<a href="#cl-741">741</a>
<a href="#cl-742">742</a>
<a href="#cl-743">743</a>
<a href="#cl-744">744</a>
<a href="#cl-745">745</a>
<a href="#cl-746">746</a>
<a href="#cl-747">747</a>
<a href="#cl-748">748</a>
<a href="#cl-749">749</a>
<a href="#cl-750">750</a>
<a href="#cl-751">751</a>
<a href="#cl-752">752</a>
<a href="#cl-753">753</a>
<a href="#cl-754">754</a>
<a href="#cl-755">755</a>
<a href="#cl-756">756</a>
<a href="#cl-757">757</a>
<a href="#cl-758">758</a>
<a href="#cl-759">759</a>
<a href="#cl-760">760</a>
<a href="#cl-761">761</a>
<a href="#cl-762">762</a>
<a href="#cl-763">763</a>
<a href="#cl-764">764</a>
<a href="#cl-765">765</a>
<a href="#cl-766">766</a>
<a href="#cl-767">767</a>
<a href="#cl-768">768</a>
<a href="#cl-769">769</a>
<a href="#cl-770">770</a>
<a href="#cl-771">771</a>
<a href="#cl-772">772</a>
<a href="#cl-773">773</a>
<a href="#cl-774">774</a>
<a href="#cl-775">775</a>
<a href="#cl-776">776</a>
<a href="#cl-777">777</a>
<a href="#cl-778">778</a>
<a href="#cl-779">779</a>
<a href="#cl-780">780</a>
<a href="#cl-781">781</a>
<a href="#cl-782">782</a>
<a href="#cl-783">783</a>
<a href="#cl-784">784</a>
<a href="#cl-785">785</a>
<a href="#cl-786">786</a>
<a href="#cl-787">787</a>
<a href="#cl-788">788</a>
<a href="#cl-789">789</a>
<a href="#cl-790">790</a>
<a href="#cl-791">791</a>
<a href="#cl-792">792</a>
<a href="#cl-793">793</a>
<a href="#cl-794">794</a>
<a href="#cl-795">795</a>
<a href="#cl-796">796</a>
<a href="#cl-797">797</a>
<a href="#cl-798">798</a>
<a href="#cl-799">799</a>
<a href="#cl-800">800</a>
<a href="#cl-801">801</a>
<a href="#cl-802">802</a>
<a href="#cl-803">803</a>
<a href="#cl-804">804</a>
<a href="#cl-805">805</a>
<a href="#cl-806">806</a>
<a href="#cl-807">807</a>
<a href="#cl-808">808</a>
<a href="#cl-809">809</a>
<a href="#cl-810">810</a>
<a href="#cl-811">811</a>
<a href="#cl-812">812</a>
<a href="#cl-813">813</a>
<a href="#cl-814">814</a>
<a href="#cl-815">815</a>
<a href="#cl-816">816</a>
<a href="#cl-817">817</a>
<a href="#cl-818">818</a>
<a href="#cl-819">819</a>
<a href="#cl-820">820</a>
<a href="#cl-821">821</a>
<a href="#cl-822">822</a>
<a href="#cl-823">823</a>
<a href="#cl-824">824</a>
<a href="#cl-825">825</a>
<a href="#cl-826">826</a>
<a href="#cl-827">827</a>
<a href="#cl-828">828</a>
<a href="#cl-829">829</a>
<a href="#cl-830">830</a>
<a href="#cl-831">831</a>
<a href="#cl-832">832</a>
<a href="#cl-833">833</a>
<a href="#cl-834">834</a>
<a href="#cl-835">835</a>
<a href="#cl-836">836</a>
<a href="#cl-837">837</a>
<a href="#cl-838">838</a>
<a href="#cl-839">839</a>
<a href="#cl-840">840</a>
<a href="#cl-841">841</a>
<a href="#cl-842">842</a>
<a href="#cl-843">843</a>
<a href="#cl-844">844</a>
<a href="#cl-845">845</a>
<a href="#cl-846">846</a>
<a href="#cl-847">847</a>
<a href="#cl-848">848</a>
<a href="#cl-849">849</a>
<a href="#cl-850">850</a>
<a href="#cl-851">851</a>
<a href="#cl-852">852</a>
<a href="#cl-853">853</a>
<a href="#cl-854">854</a>
<a href="#cl-855">855</a>
<a href="#cl-856">856</a>
<a href="#cl-857">857</a>
<a href="#cl-858">858</a>
<a href="#cl-859">859</a>
<a href="#cl-860">860</a>
<a href="#cl-861">861</a>
<a href="#cl-862">862</a>
<a href="#cl-863">863</a>
<a href="#cl-864">864</a>
<a href="#cl-865">865</a>
<a href="#cl-866">866</a>
<a href="#cl-867">867</a>
<a href="#cl-868">868</a>
<a href="#cl-869">869</a>
<a href="#cl-870">870</a>
<a href="#cl-871">871</a>
<a href="#cl-872">872</a>
<a href="#cl-873">873</a>
<a href="#cl-874">874</a>
<a href="#cl-875">875</a>
<a href="#cl-876">876</a>
<a href="#cl-877">877</a>
<a href="#cl-878">878</a>
<a href="#cl-879">879</a>
<a href="#cl-880">880</a>
<a href="#cl-881">881</a>
<a href="#cl-882">882</a>
<a href="#cl-883">883</a>
<a href="#cl-884">884</a>
<a href="#cl-885">885</a>
<a href="#cl-886">886</a>
<a href="#cl-887">887</a>
<a href="#cl-888">888</a>
<a href="#cl-889">889</a>
<a href="#cl-890">890</a>
<a href="#cl-891">891</a>
<a href="#cl-892">892</a>
<a href="#cl-893">893</a>
<a href="#cl-894">894</a>
<a href="#cl-895">895</a>
<a href="#cl-896">896</a>
<a href="#cl-897">897</a>
<a href="#cl-898">898</a>
<a href="#cl-899">899</a>
<a href="#cl-900">900</a>
<a href="#cl-901">901</a>
<a href="#cl-902">902</a>
<a href="#cl-903">903</a>
<a href="#cl-904">904</a>
<a href="#cl-905">905</a>
<a href="#cl-906">906</a>
<a href="#cl-907">907</a>
<a href="#cl-908">908</a>
<a href="#cl-909">909</a>
<a href="#cl-910">910</a>
<a href="#cl-911">911</a>
<a href="#cl-912">912</a>
<a href="#cl-913">913</a>
<a href="#cl-914">914</a>
<a href="#cl-915">915</a>
<a href="#cl-916">916</a>
<a href="#cl-917">917</a>
<a href="#cl-918">918</a>
<a href="#cl-919">919</a>
<a href="#cl-920">920</a>
<a href="#cl-921">921</a>
<a href="#cl-922">922</a>
<a href="#cl-923">923</a>
<a href="#cl-924">924</a>
<a href="#cl-925">925</a>
<a href="#cl-926">926</a>
<a href="#cl-927">927</a>
<a href="#cl-928">928</a>
<a href="#cl-929">929</a>
<a href="#cl-930">930</a>
<a href="#cl-931">931</a>
<a href="#cl-932">932</a>
<a href="#cl-933">933</a>
<a href="#cl-934">934</a>
<a href="#cl-935">935</a>
<a href="#cl-936">936</a>
<a href="#cl-937">937</a>
<a href="#cl-938">938</a>
<a href="#cl-939">939</a>
<a href="#cl-940">940</a>
<a href="#cl-941">941</a>
<a href="#cl-942">942</a>
<a href="#cl-943">943</a>
<a href="#cl-944">944</a>
<a href="#cl-945">945</a>
<a href="#cl-946">946</a>
<a href="#cl-947">947</a>
<a href="#cl-948">948</a>
<a href="#cl-949">949</a>
<a href="#cl-950">950</a>
<a href="#cl-951">951</a>
<a href="#cl-952">952</a>
<a href="#cl-953">953</a>
<a href="#cl-954">954</a>
<a href="#cl-955">955</a>
<a href="#cl-956">956</a>
<a href="#cl-957">957</a>
<a href="#cl-958">958</a>
<a href="#cl-959">959</a>
<a href="#cl-960">960</a>
<a href="#cl-961">961</a>
<a href="#cl-962">962</a>
<a href="#cl-963">963</a>
<a href="#cl-964">964</a>
<a href="#cl-965">965</a>
<a href="#cl-966">966</a>
<a href="#cl-967">967</a>
<a href="#cl-968">968</a>
<a href="#cl-969">969</a>
<a href="#cl-970">970</a>
<a href="#cl-971">971</a>
<a href="#cl-972">972</a>
<a href="#cl-973">973</a>
<a href="#cl-974">974</a>
<a href="#cl-975">975</a>
<a href="#cl-976">976</a>
<a href="#cl-977">977</a>
<a href="#cl-978">978</a>
<a href="#cl-979">979</a>
<a href="#cl-980">980</a>
<a href="#cl-981">981</a>
<a href="#cl-982">982</a>
<a href="#cl-983">983</a>
<a href="#cl-984">984</a>
<a href="#cl-985">985</a>
<a href="#cl-986">986</a>
<a href="#cl-987">987</a>
<a href="#cl-988">988</a>
<a href="#cl-989">989</a>
<a href="#cl-990">990</a>
<a href="#cl-991">991</a>
<a href="#cl-992">992</a>
<a href="#cl-993">993</a>
<a href="#cl-994">994</a>
<a href="#cl-995">995</a>
<a href="#cl-996">996</a>
<a href="#cl-997">997</a>
<a href="#cl-998">998</a>
<a href="#cl-999">999</a>
<a href="#cl-1000">1000</a>
<a href="#cl-1001">1001</a>
<a href="#cl-1002">1002</a>
<a href="#cl-1003">1003</a>
<a href="#cl-1004">1004</a>
<a href="#cl-1005">1005</a>
<a href="#cl-1006">1006</a>
<a href="#cl-1007">1007</a>
<a href="#cl-1008">1008</a>
<a href="#cl-1009">1009</a>
<a href="#cl-1010">1010</a>
<a href="#cl-1011">1011</a>
<a href="#cl-1012">1012</a>
<a href="#cl-1013">1013</a>
<a href="#cl-1014">1014</a>
<a href="#cl-1015">1015</a>
<a href="#cl-1016">1016</a>
<a href="#cl-1017">1017</a>
<a href="#cl-1018">1018</a>
<a href="#cl-1019">1019</a>
<a href="#cl-1020">1020</a>
<a href="#cl-1021">1021</a>
<a href="#cl-1022">1022</a>
<a href="#cl-1023">1023</a>
<a href="#cl-1024">1024</a>
<a href="#cl-1025">1025</a>
<a href="#cl-1026">1026</a>
<a href="#cl-1027">1027</a>
<a href="#cl-1028">1028</a>
<a href="#cl-1029">1029</a>
<a href="#cl-1030">1030</a>
<a href="#cl-1031">1031</a>
<a href="#cl-1032">1032</a>
<a href="#cl-1033">1033</a>
<a href="#cl-1034">1034</a>
<a href="#cl-1035">1035</a>
<a href="#cl-1036">1036</a>
<a href="#cl-1037">1037</a>
<a href="#cl-1038">1038</a>
<a href="#cl-1039">1039</a>
<a href="#cl-1040">1040</a>
<a href="#cl-1041">1041</a>
<a href="#cl-1042">1042</a>
<a href="#cl-1043">1043</a>
<a href="#cl-1044">1044</a>
<a href="#cl-1045">1045</a>
<a href="#cl-1046">1046</a>
<a href="#cl-1047">1047</a>
<a href="#cl-1048">1048</a>
<a href="#cl-1049">1049</a>
<a href="#cl-1050">1050</a>
<a href="#cl-1051">1051</a>
<a href="#cl-1052">1052</a>
<a href="#cl-1053">1053</a>
<a href="#cl-1054">1054</a>
<a href="#cl-1055">1055</a>
<a href="#cl-1056">1056</a>
<a href="#cl-1057">1057</a>
<a href="#cl-1058">1058</a>
<a href="#cl-1059">1059</a>
<a href="#cl-1060">1060</a>
<a href="#cl-1061">1061</a>
<a href="#cl-1062">1062</a>
<a href="#cl-1063">1063</a>
<a href="#cl-1064">1064</a>
<a href="#cl-1065">1065</a>
<a href="#cl-1066">1066</a>
<a href="#cl-1067">1067</a>
<a href="#cl-1068">1068</a>
<a href="#cl-1069">1069</a>
<a href="#cl-1070">1070</a>
<a href="#cl-1071">1071</a>
<a href="#cl-1072">1072</a>
<a href="#cl-1073">1073</a>
<a href="#cl-1074">1074</a>
<a href="#cl-1075">1075</a>
<a href="#cl-1076">1076</a>
<a href="#cl-1077">1077</a>
<a href="#cl-1078">1078</a>
<a href="#cl-1079">1079</a>
<a href="#cl-1080">1080</a>
<a href="#cl-1081">1081</a>
<a href="#cl-1082">1082</a>
<a href="#cl-1083">1083</a>
<a href="#cl-1084">1084</a>
<a href="#cl-1085">1085</a>
<a href="#cl-1086">1086</a>
<a href="#cl-1087">1087</a>
<a href="#cl-1088">1088</a>
<a href="#cl-1089">1089</a>
<a href="#cl-1090">1090</a>
<a href="#cl-1091">1091</a>
<a href="#cl-1092">1092</a>
<a href="#cl-1093">1093</a>
<a href="#cl-1094">1094</a>
<a href="#cl-1095">1095</a>
<a href="#cl-1096">1096</a>
<a href="#cl-1097">1097</a>
<a href="#cl-1098">1098</a>
<a href="#cl-1099">1099</a>
<a href="#cl-1100">1100</a>
<a href="#cl-1101">1101</a>
<a href="#cl-1102">1102</a>
<a href="#cl-1103">1103</a>
<a href="#cl-1104">1104</a>
<a href="#cl-1105">1105</a>
<a href="#cl-1106">1106</a>
<a href="#cl-1107">1107</a>
<a href="#cl-1108">1108</a>
<a href="#cl-1109">1109</a>
<a href="#cl-1110">1110</a>
<a href="#cl-1111">1111</a>
<a href="#cl-1112">1112</a>
<a href="#cl-1113">1113</a>
<a href="#cl-1114">1114</a>
<a href="#cl-1115">1115</a>
<a href="#cl-1116">1116</a>
<a href="#cl-1117">1117</a>
<a href="#cl-1118">1118</a>
<a href="#cl-1119">1119</a>
<a href="#cl-1120">1120</a>
<a href="#cl-1121">1121</a>
<a href="#cl-1122">1122</a>
<a href="#cl-1123">1123</a>
<a href="#cl-1124">1124</a>
<a href="#cl-1125">1125</a>
<a href="#cl-1126">1126</a>
<a href="#cl-1127">1127</a>
<a href="#cl-1128">1128</a>
<a href="#cl-1129">1129</a>
<a href="#cl-1130">1130</a>
<a href="#cl-1131">1131</a>
<a href="#cl-1132">1132</a>
<a href="#cl-1133">1133</a>
<a href="#cl-1134">1134</a>
<a href="#cl-1135">1135</a>
<a href="#cl-1136">1136</a>
<a href="#cl-1137">1137</a>
<a href="#cl-1138">1138</a>
<a href="#cl-1139">1139</a>
<a href="#cl-1140">1140</a>
<a href="#cl-1141">1141</a>
<a href="#cl-1142">1142</a>
<a href="#cl-1143">1143</a>
<a href="#cl-1144">1144</a>
<a href="#cl-1145">1145</a>
<a href="#cl-1146">1146</a>
<a href="#cl-1147">1147</a>
<a href="#cl-1148">1148</a>
<a href="#cl-1149">1149</a>
<a href="#cl-1150">1150</a>
<a href="#cl-1151">1151</a>
<a href="#cl-1152">1152</a>
<a href="#cl-1153">1153</a>
<a href="#cl-1154">1154</a>
<a href="#cl-1155">1155</a>
<a href="#cl-1156">1156</a>
<a href="#cl-1157">1157</a>
<a href="#cl-1158">1158</a>
<a href="#cl-1159">1159</a>
<a href="#cl-1160">1160</a>
<a href="#cl-1161">1161</a>
<a href="#cl-1162">1162</a>
<a href="#cl-1163">1163</a>
<a href="#cl-1164">1164</a>
<a href="#cl-1165">1165</a>
<a href="#cl-1166">1166</a>
<a href="#cl-1167">1167</a>
<a href="#cl-1168">1168</a>
<a href="#cl-1169">1169</a>
<a href="#cl-1170">1170</a>
<a href="#cl-1171">1171</a>
<a href="#cl-1172">1172</a>
<a href="#cl-1173">1173</a>
<a href="#cl-1174">1174</a>
<a href="#cl-1175">1175</a>
<a href="#cl-1176">1176</a>
<a href="#cl-1177">1177</a>
<a href="#cl-1178">1178</a>
<a href="#cl-1179">1179</a>
<a href="#cl-1180">1180</a>
<a href="#cl-1181">1181</a>
<a href="#cl-1182">1182</a>
<a href="#cl-1183">1183</a>
<a href="#cl-1184">1184</a>
<a href="#cl-1185">1185</a>
<a href="#cl-1186">1186</a>
<a href="#cl-1187">1187</a>
<a href="#cl-1188">1188</a>
<a href="#cl-1189">1189</a>
<a href="#cl-1190">1190</a>
<a href="#cl-1191">1191</a>
<a href="#cl-1192">1192</a>
<a href="#cl-1193">1193</a>
<a href="#cl-1194">1194</a>
<a href="#cl-1195">1195</a>
<a href="#cl-1196">1196</a>
<a href="#cl-1197">1197</a>
<a href="#cl-1198">1198</a>
<a href="#cl-1199">1199</a>
<a href="#cl-1200">1200</a>
<a href="#cl-1201">1201</a>
<a href="#cl-1202">1202</a>
<a href="#cl-1203">1203</a>
<a href="#cl-1204">1204</a>
<a href="#cl-1205">1205</a>
<a href="#cl-1206">1206</a>
<a href="#cl-1207">1207</a>
<a href="#cl-1208">1208</a>
<a href="#cl-1209">1209</a>
<a href="#cl-1210">1210</a>
<a href="#cl-1211">1211</a>
<a href="#cl-1212">1212</a>
<a href="#cl-1213">1213</a>
<a href="#cl-1214">1214</a>
<a href="#cl-1215">1215</a>
<a href="#cl-1216">1216</a>
<a href="#cl-1217">1217</a>
<a href="#cl-1218">1218</a>
<a href="#cl-1219">1219</a>
<a href="#cl-1220">1220</a>
<a href="#cl-1221">1221</a>
<a href="#cl-1222">1222</a>
<a href="#cl-1223">1223</a>
<a href="#cl-1224">1224</a>
<a href="#cl-1225">1225</a>
<a href="#cl-1226">1226</a>
<a href="#cl-1227">1227</a>
<a href="#cl-1228">1228</a>
<a href="#cl-1229">1229</a>
<a href="#cl-1230">1230</a>
<a href="#cl-1231">1231</a>
<a href="#cl-1232">1232</a>
<a href="#cl-1233">1233</a>
<a href="#cl-1234">1234</a>
<a href="#cl-1235">1235</a>
<a href="#cl-1236">1236</a>
<a href="#cl-1237">1237</a>
<a href="#cl-1238">1238</a>
<a href="#cl-1239">1239</a>
<a href="#cl-1240">1240</a>
<a href="#cl-1241">1241</a>
<a href="#cl-1242">1242</a>
<a href="#cl-1243">1243</a>
<a href="#cl-1244">1244</a>
<a href="#cl-1245">1245</a>
<a href="#cl-1246">1246</a>
<a href="#cl-1247">1247</a>
<a href="#cl-1248">1248</a>
<a href="#cl-1249">1249</a>
<a href="#cl-1250">1250</a>
<a href="#cl-1251">1251</a>
<a href="#cl-1252">1252</a>
<a href="#cl-1253">1253</a>
<a href="#cl-1254">1254</a>
<a href="#cl-1255">1255</a>
<a href="#cl-1256">1256</a>
<a href="#cl-1257">1257</a>
<a href="#cl-1258">1258</a>
<a href="#cl-1259">1259</a>
<a href="#cl-1260">1260</a>
<a href="#cl-1261">1261</a>
<a href="#cl-1262">1262</a>
<a href="#cl-1263">1263</a>
<a href="#cl-1264">1264</a>
<a href="#cl-1265">1265</a>
<a href="#cl-1266">1266</a>
<a href="#cl-1267">1267</a>
<a href="#cl-1268">1268</a>
<a href="#cl-1269">1269</a>
<a href="#cl-1270">1270</a>
<a href="#cl-1271">1271</a>
<a href="#cl-1272">1272</a>
<a href="#cl-1273">1273</a>
<a href="#cl-1274">1274</a>
<a href="#cl-1275">1275</a>
<a href="#cl-1276">1276</a>
<a href="#cl-1277">1277</a>
<a href="#cl-1278">1278</a>
<a href="#cl-1279">1279</a>
<a href="#cl-1280">1280</a>
<a href="#cl-1281">1281</a>
<a href="#cl-1282">1282</a>
<a href="#cl-1283">1283</a>
<a href="#cl-1284">1284</a>
<a href="#cl-1285">1285</a>
<a href="#cl-1286">1286</a>
<a href="#cl-1287">1287</a>
<a href="#cl-1288">1288</a>
<a href="#cl-1289">1289</a>
<a href="#cl-1290">1290</a>
<a href="#cl-1291">1291</a>
<a href="#cl-1292">1292</a>
<a href="#cl-1293">1293</a>
<a href="#cl-1294">1294</a>
<a href="#cl-1295">1295</a>
<a href="#cl-1296">1296</a>
<a href="#cl-1297">1297</a>
<a href="#cl-1298">1298</a>
<a href="#cl-1299">1299</a>
<a href="#cl-1300">1300</a>
<a href="#cl-1301">1301</a>
<a href="#cl-1302">1302</a>
<a href="#cl-1303">1303</a>
<a href="#cl-1304">1304</a>
<a href="#cl-1305">1305</a>
<a href="#cl-1306">1306</a>
<a href="#cl-1307">1307</a>
<a href="#cl-1308">1308</a>
<a href="#cl-1309">1309</a>
<a href="#cl-1310">1310</a>
<a href="#cl-1311">1311</a>
<a href="#cl-1312">1312</a>
<a href="#cl-1313">1313</a>
<a href="#cl-1314">1314</a>
<a href="#cl-1315">1315</a>
<a href="#cl-1316">1316</a>
<a href="#cl-1317">1317</a>
<a href="#cl-1318">1318</a>
<a href="#cl-1319">1319</a>
<a href="#cl-1320">1320</a>
<a href="#cl-1321">1321</a>
<a href="#cl-1322">1322</a>
<a href="#cl-1323">1323</a>
<a href="#cl-1324">1324</a>
<a href="#cl-1325">1325</a>
<a href="#cl-1326">1326</a>
<a href="#cl-1327">1327</a>
<a href="#cl-1328">1328</a>
<a href="#cl-1329">1329</a>
<a href="#cl-1330">1330</a>
<a href="#cl-1331">1331</a>
<a href="#cl-1332">1332</a>
<a href="#cl-1333">1333</a>
<a href="#cl-1334">1334</a>
<a href="#cl-1335">1335</a>
<a href="#cl-1336">1336</a>
<a href="#cl-1337">1337</a>
<a href="#cl-1338">1338</a>
<a href="#cl-1339">1339</a>
<a href="#cl-1340">1340</a>
<a href="#cl-1341">1341</a>
<a href="#cl-1342">1342</a>
<a href="#cl-1343">1343</a>
<a href="#cl-1344">1344</a>
<a href="#cl-1345">1345</a>
<a href="#cl-1346">1346</a>
<a href="#cl-1347">1347</a>
<a href="#cl-1348">1348</a>
<a href="#cl-1349">1349</a>
<a href="#cl-1350">1350</a>
<a href="#cl-1351">1351</a>
<a href="#cl-1352">1352</a>
<a href="#cl-1353">1353</a>
<a href="#cl-1354">1354</a>
<a href="#cl-1355">1355</a>
<a href="#cl-1356">1356</a>
<a href="#cl-1357">1357</a>
<a href="#cl-1358">1358</a>
<a href="#cl-1359">1359</a>
<a href="#cl-1360">1360</a>
<a href="#cl-1361">1361</a>
<a href="#cl-1362">1362</a>
<a href="#cl-1363">1363</a>
<a href="#cl-1364">1364</a>
<a href="#cl-1365">1365</a>
<a href="#cl-1366">1366</a>
<a href="#cl-1367">1367</a>
<a href="#cl-1368">1368</a>
<a href="#cl-1369">1369</a>
<a href="#cl-1370">1370</a>
<a href="#cl-1371">1371</a>
<a href="#cl-1372">1372</a>
<a href="#cl-1373">1373</a>
<a href="#cl-1374">1374</a>
<a href="#cl-1375">1375</a>
<a href="#cl-1376">1376</a>
<a href="#cl-1377">1377</a>
<a href="#cl-1378">1378</a>
<a href="#cl-1379">1379</a>
<a href="#cl-1380">1380</a>
<a href="#cl-1381">1381</a>
<a href="#cl-1382">1382</a>
<a href="#cl-1383">1383</a>
<a href="#cl-1384">1384</a>
<a href="#cl-1385">1385</a>
<a href="#cl-1386">1386</a>
<a href="#cl-1387">1387</a>
<a href="#cl-1388">1388</a>
<a href="#cl-1389">1389</a>
<a href="#cl-1390">1390</a>
<a href="#cl-1391">1391</a>
<a href="#cl-1392">1392</a>
<a href="#cl-1393">1393</a>
<a href="#cl-1394">1394</a>
<a href="#cl-1395">1395</a>
<a href="#cl-1396">1396</a>
<a href="#cl-1397">1397</a>
<a href="#cl-1398">1398</a>
<a href="#cl-1399">1399</a>
<a href="#cl-1400">1400</a>
<a href="#cl-1401">1401</a>
<a href="#cl-1402">1402</a>
<a href="#cl-1403">1403</a>
<a href="#cl-1404">1404</a>
<a href="#cl-1405">1405</a>
<a href="#cl-1406">1406</a>
<a href="#cl-1407">1407</a>
<a href="#cl-1408">1408</a>
<a href="#cl-1409">1409</a>
<a href="#cl-1410">1410</a>
<a href="#cl-1411">1411</a>
<a href="#cl-1412">1412</a>
<a href="#cl-1413">1413</a>
<a href="#cl-1414">1414</a>
<a href="#cl-1415">1415</a>
<a href="#cl-1416">1416</a>
<a href="#cl-1417">1417</a>
<a href="#cl-1418">1418</a>
<a href="#cl-1419">1419</a>
<a href="#cl-1420">1420</a>
<a href="#cl-1421">1421</a>
<a href="#cl-1422">1422</a>
<a href="#cl-1423">1423</a>
<a href="#cl-1424">1424</a>
<a href="#cl-1425">1425</a>
<a href="#cl-1426">1426</a>
<a href="#cl-1427">1427</a>
<a href="#cl-1428">1428</a>
<a href="#cl-1429">1429</a>
<a href="#cl-1430">1430</a>
<a href="#cl-1431">1431</a>
<a href="#cl-1432">1432</a>
<a href="#cl-1433">1433</a>
<a href="#cl-1434">1434</a>
<a href="#cl-1435">1435</a>
<a href="#cl-1436">1436</a>
<a href="#cl-1437">1437</a>
<a href="#cl-1438">1438</a>
<a href="#cl-1439">1439</a>
<a href="#cl-1440">1440</a>
<a href="#cl-1441">1441</a>
<a href="#cl-1442">1442</a>
<a href="#cl-1443">1443</a>
<a href="#cl-1444">1444</a>
<a href="#cl-1445">1445</a>
<a href="#cl-1446">1446</a>
<a href="#cl-1447">1447</a>
<a href="#cl-1448">1448</a>
<a href="#cl-1449">1449</a>
<a href="#cl-1450">1450</a>
<a href="#cl-1451">1451</a>
<a href="#cl-1452">1452</a>
<a href="#cl-1453">1453</a>
<a href="#cl-1454">1454</a>
<a href="#cl-1455">1455</a>
<a href="#cl-1456">1456</a>
<a href="#cl-1457">1457</a>
<a href="#cl-1458">1458</a>
<a href="#cl-1459">1459</a>
<a href="#cl-1460">1460</a>
<a href="#cl-1461">1461</a>
<a href="#cl-1462">1462</a>
<a href="#cl-1463">1463</a>
<a href="#cl-1464">1464</a>
<a href="#cl-1465">1465</a>
<a href="#cl-1466">1466</a>
<a href="#cl-1467">1467</a>
<a href="#cl-1468">1468</a>
<a href="#cl-1469">1469</a>
<a href="#cl-1470">1470</a>
<a href="#cl-1471">1471</a>
<a href="#cl-1472">1472</a>
<a href="#cl-1473">1473</a>
<a href="#cl-1474">1474</a>
<a href="#cl-1475">1475</a>
<a href="#cl-1476">1476</a>
<a href="#cl-1477">1477</a>
<a href="#cl-1478">1478</a>
<a href="#cl-1479">1479</a>
<a href="#cl-1480">1480</a>
<a href="#cl-1481">1481</a>
<a href="#cl-1482">1482</a>
<a href="#cl-1483">1483</a>
<a href="#cl-1484">1484</a>
<a href="#cl-1485">1485</a>
<a href="#cl-1486">1486</a>
<a href="#cl-1487">1487</a>
<a href="#cl-1488">1488</a>
<a href="#cl-1489">1489</a>
<a href="#cl-1490">1490</a>
<a href="#cl-1491">1491</a>
<a href="#cl-1492">1492</a>
<a href="#cl-1493">1493</a>
<a href="#cl-1494">1494</a>
<a href="#cl-1495">1495</a>
<a href="#cl-1496">1496</a>
<a href="#cl-1497">1497</a>
<a href="#cl-1498">1498</a>
<a href="#cl-1499">1499</a>
<a href="#cl-1500">1500</a>
<a href="#cl-1501">1501</a>
<a href="#cl-1502">1502</a>
<a href="#cl-1503">1503</a>
<a href="#cl-1504">1504</a>
<a href="#cl-1505">1505</a>
<a href="#cl-1506">1506</a>
<a href="#cl-1507">1507</a>
<a href="#cl-1508">1508</a>
<a href="#cl-1509">1509</a>
<a href="#cl-1510">1510</a>
<a href="#cl-1511">1511</a>
<a href="#cl-1512">1512</a>
<a href="#cl-1513">1513</a>
<a href="#cl-1514">1514</a>
<a href="#cl-1515">1515</a>
<a href="#cl-1516">1516</a>
<a href="#cl-1517">1517</a>
<a href="#cl-1518">1518</a>
<a href="#cl-1519">1519</a>
<a href="#cl-1520">1520</a>
<a href="#cl-1521">1521</a>
<a href="#cl-1522">1522</a>
<a href="#cl-1523">1523</a>
<a href="#cl-1524">1524</a>
<a href="#cl-1525">1525</a>
<a href="#cl-1526">1526</a>
<a href="#cl-1527">1527</a>
<a href="#cl-1528">1528</a>
<a href="#cl-1529">1529</a>
<a href="#cl-1530">1530</a>
<a href="#cl-1531">1531</a>
<a href="#cl-1532">1532</a>
<a href="#cl-1533">1533</a>
<a href="#cl-1534">1534</a>
<a href="#cl-1535">1535</a>
<a href="#cl-1536">1536</a>
<a href="#cl-1537">1537</a>
<a href="#cl-1538">1538</a>
<a href="#cl-1539">1539</a>
<a href="#cl-1540">1540</a>
<a href="#cl-1541">1541</a>
<a href="#cl-1542">1542</a>
<a href="#cl-1543">1543</a>
<a href="#cl-1544">1544</a>
<a href="#cl-1545">1545</a>
<a href="#cl-1546">1546</a>
<a href="#cl-1547">1547</a>
<a href="#cl-1548">1548</a>
<a href="#cl-1549">1549</a>
<a href="#cl-1550">1550</a>
<a href="#cl-1551">1551</a>
<a href="#cl-1552">1552</a>
<a href="#cl-1553">1553</a>
<a href="#cl-1554">1554</a>
<a href="#cl-1555">1555</a>
<a href="#cl-1556">1556</a>
<a href="#cl-1557">1557</a>
<a href="#cl-1558">1558</a>
<a href="#cl-1559">1559</a>
<a href="#cl-1560">1560</a>
<a href="#cl-1561">1561</a>
<a href="#cl-1562">1562</a>
<a href="#cl-1563">1563</a>
<a href="#cl-1564">1564</a>
<a href="#cl-1565">1565</a>
<a href="#cl-1566">1566</a>
<a href="#cl-1567">1567</a>
<a href="#cl-1568">1568</a>
<a href="#cl-1569">1569</a>
<a href="#cl-1570">1570</a>
<a href="#cl-1571">1571</a>
<a href="#cl-1572">1572</a>
<a href="#cl-1573">1573</a>
<a href="#cl-1574">1574</a>
<a href="#cl-1575">1575</a>
<a href="#cl-1576">1576</a>
<a href="#cl-1577">1577</a>
<a href="#cl-1578">1578</a>
<a href="#cl-1579">1579</a>
<a href="#cl-1580">1580</a>
<a href="#cl-1581">1581</a>
<a href="#cl-1582">1582</a>
<a href="#cl-1583">1583</a>
<a href="#cl-1584">1584</a>
<a href="#cl-1585">1585</a>
<a href="#cl-1586">1586</a>
<a href="#cl-1587">1587</a>
<a href="#cl-1588">1588</a>
<a href="#cl-1589">1589</a>
<a href="#cl-1590">1590</a>
<a href="#cl-1591">1591</a>
<a href="#cl-1592">1592</a>
<a href="#cl-1593">1593</a>
<a href="#cl-1594">1594</a>
<a href="#cl-1595">1595</a>
<a href="#cl-1596">1596</a>
<a href="#cl-1597">1597</a>
<a href="#cl-1598">1598</a>
<a href="#cl-1599">1599</a>
<a href="#cl-1600">1600</a>
<a href="#cl-1601">1601</a>
<a href="#cl-1602">1602</a>
<a href="#cl-1603">1603</a>
<a href="#cl-1604">1604</a>
<a href="#cl-1605">1605</a>
<a href="#cl-1606">1606</a>
<a href="#cl-1607">1607</a>
<a href="#cl-1608">1608</a>
<a href="#cl-1609">1609</a>
<a href="#cl-1610">1610</a>
<a href="#cl-1611">1611</a>
<a href="#cl-1612">1612</a>
<a href="#cl-1613">1613</a>
<a href="#cl-1614">1614</a>
<a href="#cl-1615">1615</a>
<a href="#cl-1616">1616</a>
<a href="#cl-1617">1617</a>
<a href="#cl-1618">1618</a>
<a href="#cl-1619">1619</a>
<a href="#cl-1620">1620</a>
<a href="#cl-1621">1621</a>
<a href="#cl-1622">1622</a>
<a href="#cl-1623">1623</a>
<a href="#cl-1624">1624</a>
<a href="#cl-1625">1625</a>
<a href="#cl-1626">1626</a>
<a href="#cl-1627">1627</a>
<a href="#cl-1628">1628</a>
<a href="#cl-1629">1629</a>
<a href="#cl-1630">1630</a>
<a href="#cl-1631">1631</a>
<a href="#cl-1632">1632</a>
<a href="#cl-1633">1633</a>
<a href="#cl-1634">1634</a>
<a href="#cl-1635">1635</a>
<a href="#cl-1636">1636</a>
<a href="#cl-1637">1637</a>
<a href="#cl-1638">1638</a>
<a href="#cl-1639">1639</a>
<a href="#cl-1640">1640</a>
<a href="#cl-1641">1641</a>
<a href="#cl-1642">1642</a>
<a href="#cl-1643">1643</a>
<a href="#cl-1644">1644</a>
<a href="#cl-1645">1645</a>
<a href="#cl-1646">1646</a>
<a href="#cl-1647">1647</a>
<a href="#cl-1648">1648</a>
<a href="#cl-1649">1649</a>
<a href="#cl-1650">1650</a>
<a href="#cl-1651">1651</a>
<a href="#cl-1652">1652</a>
<a href="#cl-1653">1653</a>
<a href="#cl-1654">1654</a>
<a href="#cl-1655">1655</a>
<a href="#cl-1656">1656</a>
<a href="#cl-1657">1657</a>
<a href="#cl-1658">1658</a>
<a href="#cl-1659">1659</a>
<a href="#cl-1660">1660</a>
<a href="#cl-1661">1661</a>
<a href="#cl-1662">1662</a>
<a href="#cl-1663">1663</a>
<a href="#cl-1664">1664</a>
<a href="#cl-1665">1665</a>
<a href="#cl-1666">1666</a>
<a href="#cl-1667">1667</a>
<a href="#cl-1668">1668</a>
<a href="#cl-1669">1669</a>
<a href="#cl-1670">1670</a>
<a href="#cl-1671">1671</a>
<a href="#cl-1672">1672</a>
<a href="#cl-1673">1673</a>
<a href="#cl-1674">1674</a>
<a href="#cl-1675">1675</a>
<a href="#cl-1676">1676</a>
<a href="#cl-1677">1677</a>
<a href="#cl-1678">1678</a>
<a href="#cl-1679">1679</a>
<a href="#cl-1680">1680</a>
<a href="#cl-1681">1681</a>
<a href="#cl-1682">1682</a>
<a href="#cl-1683">1683</a>
<a href="#cl-1684">1684</a>
<a href="#cl-1685">1685</a>
<a href="#cl-1686">1686</a>
<a href="#cl-1687">1687</a>
<a href="#cl-1688">1688</a>
<a href="#cl-1689">1689</a>
<a href="#cl-1690">1690</a>
<a href="#cl-1691">1691</a>
<a href="#cl-1692">1692</a>
<a href="#cl-1693">1693</a>
<a href="#cl-1694">1694</a>
<a href="#cl-1695">1695</a>
<a href="#cl-1696">1696</a>
<a href="#cl-1697">1697</a>
<a href="#cl-1698">1698</a>
<a href="#cl-1699">1699</a>
<a href="#cl-1700">1700</a>
<a href="#cl-1701">1701</a>
<a href="#cl-1702">1702</a>
<a href="#cl-1703">1703</a>
<a href="#cl-1704">1704</a>
<a href="#cl-1705">1705</a>
<a href="#cl-1706">1706</a>
<a href="#cl-1707">1707</a>
<a href="#cl-1708">1708</a>
<a href="#cl-1709">1709</a>
<a href="#cl-1710">1710</a>
<a href="#cl-1711">1711</a>
<a href="#cl-1712">1712</a>
<a href="#cl-1713">1713</a>
<a href="#cl-1714">1714</a>
<a href="#cl-1715">1715</a>
<a href="#cl-1716">1716</a>
<a href="#cl-1717">1717</a>
<a href="#cl-1718">1718</a>
<a href="#cl-1719">1719</a>
<a href="#cl-1720">1720</a>
<a href="#cl-1721">1721</a>
<a href="#cl-1722">1722</a>
<a href="#cl-1723">1723</a>
<a href="#cl-1724">1724</a>
<a href="#cl-1725">1725</a>
<a href="#cl-1726">1726</a>
<a href="#cl-1727">1727</a>
<a href="#cl-1728">1728</a>
<a href="#cl-1729">1729</a>
<a href="#cl-1730">1730</a>
<a href="#cl-1731">1731</a>
<a href="#cl-1732">1732</a>
<a href="#cl-1733">1733</a>
<a href="#cl-1734">1734</a>
<a href="#cl-1735">1735</a>
<a href="#cl-1736">1736</a>
<a href="#cl-1737">1737</a>
<a href="#cl-1738">1738</a>
<a href="#cl-1739">1739</a>
<a href="#cl-1740">1740</a>
<a href="#cl-1741">1741</a>
<a href="#cl-1742">1742</a>
<a href="#cl-1743">1743</a>
<a href="#cl-1744">1744</a>
<a href="#cl-1745">1745</a>
<a href="#cl-1746">1746</a>
<a href="#cl-1747">1747</a>
<a href="#cl-1748">1748</a>
<a href="#cl-1749">1749</a>
<a href="#cl-1750">1750</a>
<a href="#cl-1751">1751</a>
<a href="#cl-1752">1752</a>
<a href="#cl-1753">1753</a>
<a href="#cl-1754">1754</a>
<a href="#cl-1755">1755</a>
<a href="#cl-1756">1756</a>
<a href="#cl-1757">1757</a>
<a href="#cl-1758">1758</a>
<a href="#cl-1759">1759</a>
<a href="#cl-1760">1760</a>
<a href="#cl-1761">1761</a>
<a href="#cl-1762">1762</a>
<a href="#cl-1763">1763</a>
<a href="#cl-1764">1764</a>
<a href="#cl-1765">1765</a>
<a href="#cl-1766">1766</a>
<a href="#cl-1767">1767</a>
<a href="#cl-1768">1768</a>
<a href="#cl-1769">1769</a>
<a href="#cl-1770">1770</a>
<a href="#cl-1771">1771</a>
<a href="#cl-1772">1772</a>
<a href="#cl-1773">1773</a>
<a href="#cl-1774">1774</a>
<a href="#cl-1775">1775</a>
<a href="#cl-1776">1776</a>
<a href="#cl-1777">1777</a>
<a href="#cl-1778">1778</a>
<a href="#cl-1779">1779</a>
<a href="#cl-1780">1780</a>
<a href="#cl-1781">1781</a>
<a href="#cl-1782">1782</a>
<a href="#cl-1783">1783</a>
<a href="#cl-1784">1784</a>
<a href="#cl-1785">1785</a>
<a href="#cl-1786">1786</a>
<a href="#cl-1787">1787</a>
<a href="#cl-1788">1788</a>
<a href="#cl-1789">1789</a>
<a href="#cl-1790">1790</a>
<a href="#cl-1791">1791</a>
<a href="#cl-1792">1792</a>
<a href="#cl-1793">1793</a>
<a href="#cl-1794">1794</a>
<a href="#cl-1795">1795</a>
<a href="#cl-1796">1796</a>
<a href="#cl-1797">1797</a>
<a href="#cl-1798">1798</a>
<a href="#cl-1799">1799</a>
<a href="#cl-1800">1800</a>
<a href="#cl-1801">1801</a>
<a href="#cl-1802">1802</a>
<a href="#cl-1803">1803</a>
<a href="#cl-1804">1804</a>
<a href="#cl-1805">1805</a>
<a href="#cl-1806">1806</a>
<a href="#cl-1807">1807</a>
<a href="#cl-1808">1808</a>
<a href="#cl-1809">1809</a>
<a href="#cl-1810">1810</a>
<a href="#cl-1811">1811</a>
<a href="#cl-1812">1812</a>
<a href="#cl-1813">1813</a>
<a href="#cl-1814">1814</a>
<a href="#cl-1815">1815</a>
<a href="#cl-1816">1816</a>
<a href="#cl-1817">1817</a>
<a href="#cl-1818">1818</a>
<a href="#cl-1819">1819</a>
<a href="#cl-1820">1820</a>
<a href="#cl-1821">1821</a>
<a href="#cl-1822">1822</a>
<a href="#cl-1823">1823</a>
<a href="#cl-1824">1824</a>
<a href="#cl-1825">1825</a>
<a href="#cl-1826">1826</a>
<a href="#cl-1827">1827</a>
<a href="#cl-1828">1828</a>
<a href="#cl-1829">1829</a>
<a href="#cl-1830">1830</a>
<a href="#cl-1831">1831</a>
<a href="#cl-1832">1832</a>
<a href="#cl-1833">1833</a>
<a href="#cl-1834">1834</a>
<a href="#cl-1835">1835</a>
<a href="#cl-1836">1836</a>
<a href="#cl-1837">1837</a>
<a href="#cl-1838">1838</a>
<a href="#cl-1839">1839</a>
<a href="#cl-1840">1840</a>
<a href="#cl-1841">1841</a>
<a href="#cl-1842">1842</a>
<a href="#cl-1843">1843</a>
<a href="#cl-1844">1844</a>
<a href="#cl-1845">1845</a>
<a href="#cl-1846">1846</a>
<a href="#cl-1847">1847</a>
<a href="#cl-1848">1848</a>
<a href="#cl-1849">1849</a>
<a href="#cl-1850">1850</a>
<a href="#cl-1851">1851</a>
<a href="#cl-1852">1852</a>
<a href="#cl-1853">1853</a>
<a href="#cl-1854">1854</a>
<a href="#cl-1855">1855</a>
<a href="#cl-1856">1856</a>
<a href="#cl-1857">1857</a>
<a href="#cl-1858">1858</a>
<a href="#cl-1859">1859</a>
<a href="#cl-1860">1860</a>
<a href="#cl-1861">1861</a>
<a href="#cl-1862">1862</a>
<a href="#cl-1863">1863</a>
<a href="#cl-1864">1864</a>
<a href="#cl-1865">1865</a>
<a href="#cl-1866">1866</a>
<a href="#cl-1867">1867</a>
<a href="#cl-1868">1868</a>
<a href="#cl-1869">1869</a>
<a href="#cl-1870">1870</a>
<a href="#cl-1871">1871</a>
<a href="#cl-1872">1872</a>
<a href="#cl-1873">1873</a>
<a href="#cl-1874">1874</a>
<a href="#cl-1875">1875</a>
<a href="#cl-1876">1876</a>
<a href="#cl-1877">1877</a>
<a href="#cl-1878">1878</a>
<a href="#cl-1879">1879</a>
<a href="#cl-1880">1880</a>
<a href="#cl-1881">1881</a>
<a href="#cl-1882">1882</a>
<a href="#cl-1883">1883</a>
<a href="#cl-1884">1884</a>
<a href="#cl-1885">1885</a>
<a href="#cl-1886">1886</a>
<a href="#cl-1887">1887</a>
<a href="#cl-1888">1888</a>
<a href="#cl-1889">1889</a>
<a href="#cl-1890">1890</a>
<a href="#cl-1891">1891</a>
<a href="#cl-1892">1892</a>
<a href="#cl-1893">1893</a>
<a href="#cl-1894">1894</a>
<a href="#cl-1895">1895</a>
<a href="#cl-1896">1896</a>
<a href="#cl-1897">1897</a>
<a href="#cl-1898">1898</a>
<a href="#cl-1899">1899</a>
<a href="#cl-1900">1900</a>
<a href="#cl-1901">1901</a>
<a href="#cl-1902">1902</a>
<a href="#cl-1903">1903</a>
<a href="#cl-1904">1904</a>
<a href="#cl-1905">1905</a>
<a href="#cl-1906">1906</a>
<a href="#cl-1907">1907</a>
<a href="#cl-1908">1908</a>
<a href="#cl-1909">1909</a>
<a href="#cl-1910">1910</a>
<a href="#cl-1911">1911</a>
<a href="#cl-1912">1912</a>
<a href="#cl-1913">1913</a>
<a href="#cl-1914">1914</a>
<a href="#cl-1915">1915</a>
<a href="#cl-1916">1916</a>
<a href="#cl-1917">1917</a>
<a href="#cl-1918">1918</a>
<a href="#cl-1919">1919</a>
<a href="#cl-1920">1920</a>
<a href="#cl-1921">1921</a>
<a href="#cl-1922">1922</a>
<a href="#cl-1923">1923</a>
<a href="#cl-1924">1924</a>
<a href="#cl-1925">1925</a>
<a href="#cl-1926">1926</a>
<a href="#cl-1927">1927</a>
<a href="#cl-1928">1928</a>
<a href="#cl-1929">1929</a>
<a href="#cl-1930">1930</a>
<a href="#cl-1931">1931</a>
<a href="#cl-1932">1932</a>
<a href="#cl-1933">1933</a>
<a href="#cl-1934">1934</a>
<a href="#cl-1935">1935</a>
<a href="#cl-1936">1936</a>
<a href="#cl-1937">1937</a>
<a href="#cl-1938">1938</a>
<a href="#cl-1939">1939</a>
<a href="#cl-1940">1940</a>
<a href="#cl-1941">1941</a>
<a href="#cl-1942">1942</a>
<a href="#cl-1943">1943</a>
<a href="#cl-1944">1944</a>
<a href="#cl-1945">1945</a>
<a href="#cl-1946">1946</a>
<a href="#cl-1947">1947</a>
<a href="#cl-1948">1948</a>
<a href="#cl-1949">1949</a>
<a href="#cl-1950">1950</a>
<a href="#cl-1951">1951</a>
<a href="#cl-1952">1952</a>
<a href="#cl-1953">1953</a>
<a href="#cl-1954">1954</a>
<a href="#cl-1955">1955</a>
<a href="#cl-1956">1956</a>
<a href="#cl-1957">1957</a>
<a href="#cl-1958">1958</a>
<a href="#cl-1959">1959</a>
<a href="#cl-1960">1960</a>
<a href="#cl-1961">1961</a>
<a href="#cl-1962">1962</a>
<a href="#cl-1963">1963</a>
<a href="#cl-1964">1964</a>
<a href="#cl-1965">1965</a>
<a href="#cl-1966">1966</a>
<a href="#cl-1967">1967</a>
<a href="#cl-1968">1968</a>
<a href="#cl-1969">1969</a>
<a href="#cl-1970">1970</a>
<a href="#cl-1971">1971</a>
<a href="#cl-1972">1972</a>
<a href="#cl-1973">1973</a>
<a href="#cl-1974">1974</a>
<a href="#cl-1975">1975</a>
<a href="#cl-1976">1976</a>
<a href="#cl-1977">1977</a>
<a href="#cl-1978">1978</a>
<a href="#cl-1979">1979</a>
<a href="#cl-1980">1980</a>
<a href="#cl-1981">1981</a>
<a href="#cl-1982">1982</a>
<a href="#cl-1983">1983</a>
<a href="#cl-1984">1984</a>
<a href="#cl-1985">1985</a>
<a href="#cl-1986">1986</a>
<a href="#cl-1987">1987</a>
<a href="#cl-1988">1988</a>
<a href="#cl-1989">1989</a>
<a href="#cl-1990">1990</a>
<a href="#cl-1991">1991</a>
<a href="#cl-1992">1992</a>
<a href="#cl-1993">1993</a>
<a href="#cl-1994">1994</a>
<a href="#cl-1995">1995</a>
<a href="#cl-1996">1996</a>
<a href="#cl-1997">1997</a>
<a href="#cl-1998">1998</a>
<a href="#cl-1999">1999</a>
<a href="#cl-2000">2000</a>
<a href="#cl-2001">2001</a>
<a href="#cl-2002">2002</a>
<a href="#cl-2003">2003</a>
<a href="#cl-2004">2004</a>
<a href="#cl-2005">2005</a>
<a href="#cl-2006">2006</a>
<a href="#cl-2007">2007</a>
<a href="#cl-2008">2008</a>
<a href="#cl-2009">2009</a>
<a href="#cl-2010">2010</a>
<a href="#cl-2011">2011</a>
<a href="#cl-2012">2012</a>
<a href="#cl-2013">2013</a>
<a href="#cl-2014">2014</a>
<a href="#cl-2015">2015</a>
<a href="#cl-2016">2016</a>
<a href="#cl-2017">2017</a>
<a href="#cl-2018">2018</a>
<a href="#cl-2019">2019</a>
<a href="#cl-2020">2020</a>
<a href="#cl-2021">2021</a>
<a href="#cl-2022">2022</a>
<a href="#cl-2023">2023</a>
<a href="#cl-2024">2024</a>
<a href="#cl-2025">2025</a>
<a href="#cl-2026">2026</a>
<a href="#cl-2027">2027</a>
<a href="#cl-2028">2028</a>
<a href="#cl-2029">2029</a>
<a href="#cl-2030">2030</a>
<a href="#cl-2031">2031</a>
<a href="#cl-2032">2032</a>
<a href="#cl-2033">2033</a>
<a href="#cl-2034">2034</a>
<a href="#cl-2035">2035</a>
<a href="#cl-2036">2036</a>
<a href="#cl-2037">2037</a>
<a href="#cl-2038">2038</a>
<a href="#cl-2039">2039</a>
<a href="#cl-2040">2040</a>
<a href="#cl-2041">2041</a>
<a href="#cl-2042">2042</a>
<a href="#cl-2043">2043</a>
<a href="#cl-2044">2044</a>
<a href="#cl-2045">2045</a>
<a href="#cl-2046">2046</a>
<a href="#cl-2047">2047</a>
<a href="#cl-2048">2048</a>
<a href="#cl-2049">2049</a>
<a href="#cl-2050">2050</a>
<a href="#cl-2051">2051</a>
<a href="#cl-2052">2052</a>
<a href="#cl-2053">2053</a>
<a href="#cl-2054">2054</a>
<a href="#cl-2055">2055</a>
<a href="#cl-2056">2056</a>
<a href="#cl-2057">2057</a>
<a href="#cl-2058">2058</a>
<a href="#cl-2059">2059</a>
<a href="#cl-2060">2060</a>
<a href="#cl-2061">2061</a>
<a href="#cl-2062">2062</a>
<a href="#cl-2063">2063</a>
<a href="#cl-2064">2064</a>
<a href="#cl-2065">2065</a>
<a href="#cl-2066">2066</a>
<a href="#cl-2067">2067</a>
<a href="#cl-2068">2068</a>
<a href="#cl-2069">2069</a>
<a href="#cl-2070">2070</a>
<a href="#cl-2071">2071</a>
<a href="#cl-2072">2072</a>
<a href="#cl-2073">2073</a>
<a href="#cl-2074">2074</a>
<a href="#cl-2075">2075</a>
<a href="#cl-2076">2076</a>
<a href="#cl-2077">2077</a>
<a href="#cl-2078">2078</a>
<a href="#cl-2079">2079</a>
<a href="#cl-2080">2080</a>
<a href="#cl-2081">2081</a>
<a href="#cl-2082">2082</a>
<a href="#cl-2083">2083</a>
<a href="#cl-2084">2084</a>
<a href="#cl-2085">2085</a>
<a href="#cl-2086">2086</a>
<a href="#cl-2087">2087</a>
<a href="#cl-2088">2088</a>
<a href="#cl-2089">2089</a>
<a href="#cl-2090">2090</a>
<a href="#cl-2091">2091</a>
<a href="#cl-2092">2092</a>
<a href="#cl-2093">2093</a>
<a href="#cl-2094">2094</a>
<a href="#cl-2095">2095</a>
<a href="#cl-2096">2096</a>
<a href="#cl-2097">2097</a>
<a href="#cl-2098">2098</a>
<a href="#cl-2099">2099</a>
<a href="#cl-2100">2100</a>
<a href="#cl-2101">2101</a>
<a href="#cl-2102">2102</a>
<a href="#cl-2103">2103</a>
<a href="#cl-2104">2104</a>
<a href="#cl-2105">2105</a>
<a href="#cl-2106">2106</a>
<a href="#cl-2107">2107</a>
<a href="#cl-2108">2108</a>
<a href="#cl-2109">2109</a>
<a href="#cl-2110">2110</a>
<a href="#cl-2111">2111</a>
<a href="#cl-2112">2112</a>
<a href="#cl-2113">2113</a>
<a href="#cl-2114">2114</a>
<a href="#cl-2115">2115</a>
<a href="#cl-2116">2116</a>
<a href="#cl-2117">2117</a>
<a href="#cl-2118">2118</a>
<a href="#cl-2119">2119</a>
<a href="#cl-2120">2120</a>
<a href="#cl-2121">2121</a>
<a href="#cl-2122">2122</a>
<a href="#cl-2123">2123</a>
<a href="#cl-2124">2124</a>
<a href="#cl-2125">2125</a>
<a href="#cl-2126">2126</a>
<a href="#cl-2127">2127</a>
<a href="#cl-2128">2128</a>
<a href="#cl-2129">2129</a>
<a href="#cl-2130">2130</a>
<a href="#cl-2131">2131</a>
<a href="#cl-2132">2132</a>
<a href="#cl-2133">2133</a>
<a href="#cl-2134">2134</a>
<a href="#cl-2135">2135</a>
<a href="#cl-2136">2136</a>
<a href="#cl-2137">2137</a>
<a href="#cl-2138">2138</a>
<a href="#cl-2139">2139</a>
<a href="#cl-2140">2140</a>
<a href="#cl-2141">2141</a>
<a href="#cl-2142">2142</a>
<a href="#cl-2143">2143</a>
<a href="#cl-2144">2144</a>
<a href="#cl-2145">2145</a>
<a href="#cl-2146">2146</a>
<a href="#cl-2147">2147</a>
<a href="#cl-2148">2148</a>
<a href="#cl-2149">2149</a>
<a href="#cl-2150">2150</a>
<a href="#cl-2151">2151</a>
<a href="#cl-2152">2152</a>
<a href="#cl-2153">2153</a>
<a href="#cl-2154">2154</a>
<a href="#cl-2155">2155</a>
<a href="#cl-2156">2156</a>
<a href="#cl-2157">2157</a>
<a href="#cl-2158">2158</a>
<a href="#cl-2159">2159</a>
<a href="#cl-2160">2160</a>
<a href="#cl-2161">2161</a>
<a href="#cl-2162">2162</a>
<a href="#cl-2163">2163</a>
<a href="#cl-2164">2164</a>
<a href="#cl-2165">2165</a>
<a href="#cl-2166">2166</a>
<a href="#cl-2167">2167</a>
<a href="#cl-2168">2168</a>
<a href="#cl-2169">2169</a>
<a href="#cl-2170">2170</a>
<a href="#cl-2171">2171</a>
<a href="#cl-2172">2172</a>
<a href="#cl-2173">2173</a>
<a href="#cl-2174">2174</a>
<a href="#cl-2175">2175</a>
<a href="#cl-2176">2176</a>
<a href="#cl-2177">2177</a>
<a href="#cl-2178">2178</a>
<a href="#cl-2179">2179</a>
<a href="#cl-2180">2180</a>
<a href="#cl-2181">2181</a>
<a href="#cl-2182">2182</a>
<a href="#cl-2183">2183</a>
<a href="#cl-2184">2184</a>
<a href="#cl-2185">2185</a>
<a href="#cl-2186">2186</a>
<a href="#cl-2187">2187</a>
<a href="#cl-2188">2188</a>
<a href="#cl-2189">2189</a>
<a href="#cl-2190">2190</a>
<a href="#cl-2191">2191</a>
<a href="#cl-2192">2192</a>
<a href="#cl-2193">2193</a>
<a href="#cl-2194">2194</a>
<a href="#cl-2195">2195</a>
<a href="#cl-2196">2196</a>
<a href="#cl-2197">2197</a>
<a href="#cl-2198">2198</a>
<a href="#cl-2199">2199</a>
<a href="#cl-2200">2200</a>
<a href="#cl-2201">2201</a>
<a href="#cl-2202">2202</a>
<a href="#cl-2203">2203</a>
<a href="#cl-2204">2204</a>
<a href="#cl-2205">2205</a>
<a href="#cl-2206">2206</a>
<a href="#cl-2207">2207</a>
<a href="#cl-2208">2208</a>
<a href="#cl-2209">2209</a>
<a href="#cl-2210">2210</a>
<a href="#cl-2211">2211</a>
<a href="#cl-2212">2212</a>
<a href="#cl-2213">2213</a>
<a href="#cl-2214">2214</a>
<a href="#cl-2215">2215</a>
<a href="#cl-2216">2216</a>
<a href="#cl-2217">2217</a>
<a href="#cl-2218">2218</a>
<a href="#cl-2219">2219</a>
<a href="#cl-2220">2220</a>
<a href="#cl-2221">2221</a>
<a href="#cl-2222">2222</a>
<a href="#cl-2223">2223</a>
<a href="#cl-2224">2224</a>
<a href="#cl-2225">2225</a>
<a href="#cl-2226">2226</a>
<a href="#cl-2227">2227</a>
<a href="#cl-2228">2228</a>
<a href="#cl-2229">2229</a>
<a href="#cl-2230">2230</a>
<a href="#cl-2231">2231</a>
<a href="#cl-2232">2232</a>
<a href="#cl-2233">2233</a>
<a href="#cl-2234">2234</a>
<a href="#cl-2235">2235</a>
<a href="#cl-2236">2236</a>
<a href="#cl-2237">2237</a>
<a href="#cl-2238">2238</a>
<a href="#cl-2239">2239</a>
<a href="#cl-2240">2240</a>
<a href="#cl-2241">2241</a>
<a href="#cl-2242">2242</a>
<a href="#cl-2243">2243</a>
<a href="#cl-2244">2244</a>
<a href="#cl-2245">2245</a>
<a href="#cl-2246">2246</a>
<a href="#cl-2247">2247</a>
<a href="#cl-2248">2248</a>
<a href="#cl-2249">2249</a>
<a href="#cl-2250">2250</a>
<a href="#cl-2251">2251</a>
<a href="#cl-2252">2252</a>
<a href="#cl-2253">2253</a>
<a href="#cl-2254">2254</a>
<a href="#cl-2255">2255</a>
<a href="#cl-2256">2256</a>
<a href="#cl-2257">2257</a>
<a href="#cl-2258">2258</a>
<a href="#cl-2259">2259</a>
<a href="#cl-2260">2260</a>
<a href="#cl-2261">2261</a>
<a href="#cl-2262">2262</a>
<a href="#cl-2263">2263</a>
<a href="#cl-2264">2264</a>
<a href="#cl-2265">2265</a>
<a href="#cl-2266">2266</a>
<a href="#cl-2267">2267</a>
<a href="#cl-2268">2268</a>
<a href="#cl-2269">2269</a>
<a href="#cl-2270">2270</a>
<a href="#cl-2271">2271</a>
<a href="#cl-2272">2272</a>
<a href="#cl-2273">2273</a>
<a href="#cl-2274">2274</a>
<a href="#cl-2275">2275</a>
<a href="#cl-2276">2276</a>
<a href="#cl-2277">2277</a>
<a href="#cl-2278">2278</a>
<a href="#cl-2279">2279</a>
<a href="#cl-2280">2280</a>
<a href="#cl-2281">2281</a>
<a href="#cl-2282">2282</a>
<a href="#cl-2283">2283</a>
<a href="#cl-2284">2284</a>
<a href="#cl-2285">2285</a>
<a href="#cl-2286">2286</a>
<a href="#cl-2287">2287</a>
<a href="#cl-2288">2288</a>
<a href="#cl-2289">2289</a>
<a href="#cl-2290">2290</a>
<a href="#cl-2291">2291</a>
<a href="#cl-2292">2292</a>
<a href="#cl-2293">2293</a>
<a href="#cl-2294">2294</a>
<a href="#cl-2295">2295</a>
<a href="#cl-2296">2296</a>
<a href="#cl-2297">2297</a>
<a href="#cl-2298">2298</a>
<a href="#cl-2299">2299</a>
<a href="#cl-2300">2300</a>
<a href="#cl-2301">2301</a>
<a href="#cl-2302">2302</a>
<a href="#cl-2303">2303</a>
<a href="#cl-2304">2304</a>
<a href="#cl-2305">2305</a>
<a href="#cl-2306">2306</a>
<a href="#cl-2307">2307</a>
<a href="#cl-2308">2308</a>
<a href="#cl-2309">2309</a>
<a href="#cl-2310">2310</a>
<a href="#cl-2311">2311</a>
<a href="#cl-2312">2312</a>
<a href="#cl-2313">2313</a>
<a href="#cl-2314">2314</a>
<a href="#cl-2315">2315</a>
<a href="#cl-2316">2316</a>
<a href="#cl-2317">2317</a>
<a href="#cl-2318">2318</a>
<a href="#cl-2319">2319</a>
<a href="#cl-2320">2320</a>
<a href="#cl-2321">2321</a>
<a href="#cl-2322">2322</a>
<a href="#cl-2323">2323</a>
<a href="#cl-2324">2324</a>
<a href="#cl-2325">2325</a>
<a href="#cl-2326">2326</a>
<a href="#cl-2327">2327</a>
<a href="#cl-2328">2328</a>
<a href="#cl-2329">2329</a>
<a href="#cl-2330">2330</a>
<a href="#cl-2331">2331</a>
<a href="#cl-2332">2332</a>
<a href="#cl-2333">2333</a>
<a href="#cl-2334">2334</a>
<a href="#cl-2335">2335</a>
<a href="#cl-2336">2336</a>
<a href="#cl-2337">2337</a>
<a href="#cl-2338">2338</a>
<a href="#cl-2339">2339</a>
<a href="#cl-2340">2340</a>
<a href="#cl-2341">2341</a>
<a href="#cl-2342">2342</a>
<a href="#cl-2343">2343</a>
<a href="#cl-2344">2344</a>
<a href="#cl-2345">2345</a>
<a href="#cl-2346">2346</a>
<a href="#cl-2347">2347</a>
<a href="#cl-2348">2348</a>
<a href="#cl-2349">2349</a>
<a href="#cl-2350">2350</a>
<a href="#cl-2351">2351</a>
<a href="#cl-2352">2352</a>
<a href="#cl-2353">2353</a>
<a href="#cl-2354">2354</a>
<a href="#cl-2355">2355</a>
<a href="#cl-2356">2356</a>
<a href="#cl-2357">2357</a>
<a href="#cl-2358">2358</a>
<a href="#cl-2359">2359</a>
<a href="#cl-2360">2360</a>
<a href="#cl-2361">2361</a>
<a href="#cl-2362">2362</a>
<a href="#cl-2363">2363</a>
<a href="#cl-2364">2364</a>
<a href="#cl-2365">2365</a>
<a href="#cl-2366">2366</a>
<a href="#cl-2367">2367</a>
<a href="#cl-2368">2368</a>
<a href="#cl-2369">2369</a>
<a href="#cl-2370">2370</a>
<a href="#cl-2371">2371</a>
<a href="#cl-2372">2372</a>
<a href="#cl-2373">2373</a>
<a href="#cl-2374">2374</a>
<a href="#cl-2375">2375</a>
<a href="#cl-2376">2376</a>
<a href="#cl-2377">2377</a>
<a href="#cl-2378">2378</a>
<a href="#cl-2379">2379</a>
<a href="#cl-2380">2380</a>
<a href="#cl-2381">2381</a>
<a href="#cl-2382">2382</a>
<a href="#cl-2383">2383</a>
<a href="#cl-2384">2384</a>
<a href="#cl-2385">2385</a>
<a href="#cl-2386">2386</a>
<a href="#cl-2387">2387</a>
<a href="#cl-2388">2388</a>
<a href="#cl-2389">2389</a>
<a href="#cl-2390">2390</a>
<a href="#cl-2391">2391</a>
<a href="#cl-2392">2392</a>
<a href="#cl-2393">2393</a>
<a href="#cl-2394">2394</a>
<a href="#cl-2395">2395</a>
<a href="#cl-2396">2396</a>
<a href="#cl-2397">2397</a>
<a href="#cl-2398">2398</a>
<a href="#cl-2399">2399</a>
<a href="#cl-2400">2400</a>
<a href="#cl-2401">2401</a>
<a href="#cl-2402">2402</a>
<a href="#cl-2403">2403</a>
<a href="#cl-2404">2404</a>
<a href="#cl-2405">2405</a>
<a href="#cl-2406">2406</a>
<a href="#cl-2407">2407</a>
<a href="#cl-2408">2408</a>
<a href="#cl-2409">2409</a>
<a href="#cl-2410">2410</a>
<a href="#cl-2411">2411</a>
<a href="#cl-2412">2412</a>
<a href="#cl-2413">2413</a>
<a href="#cl-2414">2414</a>
<a href="#cl-2415">2415</a>
<a href="#cl-2416">2416</a>
<a href="#cl-2417">2417</a>
<a href="#cl-2418">2418</a>
<a href="#cl-2419">2419</a>
<a href="#cl-2420">2420</a>
<a href="#cl-2421">2421</a>
<a href="#cl-2422">2422</a>
<a href="#cl-2423">2423</a>
<a href="#cl-2424">2424</a>
<a href="#cl-2425">2425</a>
<a href="#cl-2426">2426</a>
<a href="#cl-2427">2427</a>
<a href="#cl-2428">2428</a>
<a href="#cl-2429">2429</a>
<a href="#cl-2430">2430</a>
<a href="#cl-2431">2431</a>
<a href="#cl-2432">2432</a>
<a href="#cl-2433">2433</a>
<a href="#cl-2434">2434</a>
<a href="#cl-2435">2435</a>
<a href="#cl-2436">2436</a>
<a href="#cl-2437">2437</a>
<a href="#cl-2438">2438</a>
<a href="#cl-2439">2439</a>
<a href="#cl-2440">2440</a>
<a href="#cl-2441">2441</a>
<a href="#cl-2442">2442</a>
<a href="#cl-2443">2443</a>
<a href="#cl-2444">2444</a>
<a href="#cl-2445">2445</a>
<a href="#cl-2446">2446</a>
<a href="#cl-2447">2447</a>
<a href="#cl-2448">2448</a>
<a href="#cl-2449">2449</a>
<a href="#cl-2450">2450</a>
<a href="#cl-2451">2451</a>
<a href="#cl-2452">2452</a>
<a href="#cl-2453">2453</a>
<a href="#cl-2454">2454</a>
<a href="#cl-2455">2455</a>
<a href="#cl-2456">2456</a>
<a href="#cl-2457">2457</a>
<a href="#cl-2458">2458</a>
<a href="#cl-2459">2459</a>
<a href="#cl-2460">2460</a>
<a href="#cl-2461">2461</a>
<a href="#cl-2462">2462</a>
<a href="#cl-2463">2463</a>
<a href="#cl-2464">2464</a>
<a href="#cl-2465">2465</a>
<a href="#cl-2466">2466</a>
<a href="#cl-2467">2467</a>
<a href="#cl-2468">2468</a>
<a href="#cl-2469">2469</a>
<a href="#cl-2470">2470</a>
<a href="#cl-2471">2471</a>
<a href="#cl-2472">2472</a>
<a href="#cl-2473">2473</a>
<a href="#cl-2474">2474</a>
<a href="#cl-2475">2475</a>
<a href="#cl-2476">2476</a>
<a href="#cl-2477">2477</a>
<a href="#cl-2478">2478</a>
<a href="#cl-2479">2479</a>
<a href="#cl-2480">2480</a>
<a href="#cl-2481">2481</a>
<a href="#cl-2482">2482</a>
<a href="#cl-2483">2483</a>
<a href="#cl-2484">2484</a>
<a href="#cl-2485">2485</a>
<a href="#cl-2486">2486</a>
<a href="#cl-2487">2487</a>
<a href="#cl-2488">2488</a>
<a href="#cl-2489">2489</a>
<a href="#cl-2490">2490</a>
<a href="#cl-2491">2491</a>
<a href="#cl-2492">2492</a>
<a href="#cl-2493">2493</a>
<a href="#cl-2494">2494</a>
<a href="#cl-2495">2495</a>
<a href="#cl-2496">2496</a>
<a href="#cl-2497">2497</a>
<a href="#cl-2498">2498</a>
<a href="#cl-2499">2499</a>
<a href="#cl-2500">2500</a>
<a href="#cl-2501">2501</a>
<a href="#cl-2502">2502</a>
<a href="#cl-2503">2503</a>
<a href="#cl-2504">2504</a>
<a href="#cl-2505">2505</a>
<a href="#cl-2506">2506</a>
<a href="#cl-2507">2507</a>
<a href="#cl-2508">2508</a>
<a href="#cl-2509">2509</a>
<a href="#cl-2510">2510</a>
<a href="#cl-2511">2511</a>
<a href="#cl-2512">2512</a>
<a href="#cl-2513">2513</a>
<a href="#cl-2514">2514</a>
<a href="#cl-2515">2515</a>
<a href="#cl-2516">2516</a>
<a href="#cl-2517">2517</a>
<a href="#cl-2518">2518</a>
<a href="#cl-2519">2519</a>
<a href="#cl-2520">2520</a>
<a href="#cl-2521">2521</a>
<a href="#cl-2522">2522</a>
<a href="#cl-2523">2523</a>
<a href="#cl-2524">2524</a>
<a href="#cl-2525">2525</a>
<a href="#cl-2526">2526</a>
<a href="#cl-2527">2527</a>
<a href="#cl-2528">2528</a>
<a href="#cl-2529">2529</a>
<a href="#cl-2530">2530</a>
<a href="#cl-2531">2531</a>
<a href="#cl-2532">2532</a>
<a href="#cl-2533">2533</a>
<a href="#cl-2534">2534</a>
<a href="#cl-2535">2535</a>
<a href="#cl-2536">2536</a>
<a href="#cl-2537">2537</a>
<a href="#cl-2538">2538</a>
<a href="#cl-2539">2539</a>
<a href="#cl-2540">2540</a>
<a href="#cl-2541">2541</a>
<a href="#cl-2542">2542</a>
<a href="#cl-2543">2543</a>
<a href="#cl-2544">2544</a>
<a href="#cl-2545">2545</a>
<a href="#cl-2546">2546</a>
<a href="#cl-2547">2547</a>
<a href="#cl-2548">2548</a>
<a href="#cl-2549">2549</a>
<a href="#cl-2550">2550</a>
<a href="#cl-2551">2551</a>
<a href="#cl-2552">2552</a>
<a href="#cl-2553">2553</a>
<a href="#cl-2554">2554</a>
<a href="#cl-2555">2555</a>
<a href="#cl-2556">2556</a>
<a href="#cl-2557">2557</a>
<a href="#cl-2558">2558</a>
<a href="#cl-2559">2559</a>
<a href="#cl-2560">2560</a>
<a href="#cl-2561">2561</a>
<a href="#cl-2562">2562</a>
<a href="#cl-2563">2563</a>
<a href="#cl-2564">2564</a>
<a href="#cl-2565">2565</a>
<a href="#cl-2566">2566</a>
<a href="#cl-2567">2567</a>
<a href="#cl-2568">2568</a>
<a href="#cl-2569">2569</a>
<a href="#cl-2570">2570</a>
<a href="#cl-2571">2571</a>
<a href="#cl-2572">2572</a>
<a href="#cl-2573">2573</a>
<a href="#cl-2574">2574</a>
<a href="#cl-2575">2575</a>
<a href="#cl-2576">2576</a>
<a href="#cl-2577">2577</a>
<a href="#cl-2578">2578</a>
<a href="#cl-2579">2579</a>
<a href="#cl-2580">2580</a>
<a href="#cl-2581">2581</a>
<a href="#cl-2582">2582</a>
<a href="#cl-2583">2583</a>
<a href="#cl-2584">2584</a>
<a href="#cl-2585">2585</a>
<a href="#cl-2586">2586</a>
<a href="#cl-2587">2587</a>
<a href="#cl-2588">2588</a>
<a href="#cl-2589">2589</a>
<a href="#cl-2590">2590</a>
<a href="#cl-2591">2591</a>
<a href="#cl-2592">2592</a>
<a href="#cl-2593">2593</a>
<a href="#cl-2594">2594</a>
<a href="#cl-2595">2595</a>
<a href="#cl-2596">2596</a>
</pre></div></td>
<td class="code"><div class="highlight"><pre>
<a name="cl-1"></a>#ifndef RAPIDXML_HPP_INCLUDED
<a name="cl-2"></a>#define RAPIDXML_HPP_INCLUDED
<a name="cl-3"></a>
<a name="cl-4"></a>// Copyright (C) 2006, 2009 Marcin Kalicinski
<a name="cl-5"></a>// Version 1.13
<a name="cl-6"></a>// Revision $DateTime: 2009/05/13 01:46:17 $
<a name="cl-7"></a>//! \file rapidxml.hpp This file contains rapidxml parser and DOM implementation
<a name="cl-8"></a>
<a name="cl-9"></a>// If standard library is disabled, user must provide implementations of required functions and typedefs
<a name="cl-10"></a>#if !defined(RAPIDXML_NO_STDLIB)
<a name="cl-11"></a>    #include &lt;cstdlib&gt;      // For std::size_t
<a name="cl-12"></a>    #include &lt;cassert&gt;      // For assert
<a name="cl-13"></a>    #include &lt;new&gt;          // For placement new
<a name="cl-14"></a>#endif
<a name="cl-15"></a>
<a name="cl-16"></a>// On MSVC, disable "conditional expression is constant" warning (level 4). 
<a name="cl-17"></a>// This warning is almost impossible to avoid with certain types of templated code
<a name="cl-18"></a>#ifdef _MSC_VER
<a name="cl-19"></a>    #pragma warning(push)
<a name="cl-20"></a>    #pragma warning(disable:4127)   // Conditional expression is constant
<a name="cl-21"></a>#endif
<a name="cl-22"></a>
<a name="cl-23"></a>///////////////////////////////////////////////////////////////////////////
<a name="cl-24"></a>// RAPIDXML_PARSE_ERROR
<a name="cl-25"></a>    
<a name="cl-26"></a>#if defined(RAPIDXML_NO_EXCEPTIONS)
<a name="cl-27"></a>
<a name="cl-28"></a>#define RAPIDXML_PARSE_ERROR(what, where) { parse_error_handler(what, where); assert(0); }
<a name="cl-29"></a>
<a name="cl-30"></a>namespace rapidxml
<a name="cl-31"></a>{
<a name="cl-32"></a>    //! When exceptions are disabled by defining RAPIDXML_NO_EXCEPTIONS, 
<a name="cl-33"></a>    //! this function is called to notify user about the error.
<a name="cl-34"></a>    //! It must be defined by the user.
<a name="cl-35"></a>    //! &lt;br&gt;&lt;br&gt;
<a name="cl-36"></a>    //! This function cannot return. If it does, the results are undefined.
<a name="cl-37"></a>    //! &lt;br&gt;&lt;br&gt;
<a name="cl-38"></a>    //! A very simple definition might look like that:
<a name="cl-39"></a>    //! &lt;pre&gt;
<a name="cl-40"></a>    //! void %rapidxml::%parse_error_handler(const char *what, void *where)
<a name="cl-41"></a>    //! {
<a name="cl-42"></a>    //!     std::cout &lt;&lt; "Parse error: " &lt;&lt; what &lt;&lt; "\n";
<a name="cl-43"></a>    //!     std::abort();
<a name="cl-44"></a>    //! }
<a name="cl-45"></a>    //! &lt;/pre&gt;
<a name="cl-46"></a>    //! \param what Human readable description of the error.
<a name="cl-47"></a>    //! \param where Pointer to character data where error was detected.
<a name="cl-48"></a>    void parse_error_handler(const char *what, void *where);
<a name="cl-49"></a>}
<a name="cl-50"></a>
<a name="cl-51"></a>#else
<a name="cl-52"></a>    
<a name="cl-53"></a>#include &lt;exception&gt;    // For std::exception
<a name="cl-54"></a>
<a name="cl-55"></a>#define RAPIDXML_PARSE_ERROR(what, where) throw parse_error(what, where)
<a name="cl-56"></a>
<a name="cl-57"></a>namespace rapidxml
<a name="cl-58"></a>{
<a name="cl-59"></a>
<a name="cl-60"></a>    //! Parse error exception. 
<a name="cl-61"></a>    //! This exception is thrown by the parser when an error occurs. 
<a name="cl-62"></a>    //! Use what() function to get human-readable error message. 
<a name="cl-63"></a>    //! Use where() function to get a pointer to position within source text where error was detected.
<a name="cl-64"></a>    //! &lt;br&gt;&lt;br&gt;
<a name="cl-65"></a>    //! If throwing exceptions by the parser is undesirable, 
<a name="cl-66"></a>    //! it can be disabled by defining RAPIDXML_NO_EXCEPTIONS macro before rapidxml.hpp is included.
<a name="cl-67"></a>    //! This will cause the parser to call rapidxml::parse_error_handler() function instead of throwing an exception.
<a name="cl-68"></a>    //! This function must be defined by the user.
<a name="cl-69"></a>    //! &lt;br&gt;&lt;br&gt;
<a name="cl-70"></a>    //! This class derives from &lt;code&gt;std::exception&lt;/code&gt; class.
<a name="cl-71"></a>    class parse_error: public std::exception
<a name="cl-72"></a>    {
<a name="cl-73"></a>    
<a name="cl-74"></a>    public:
<a name="cl-75"></a>    
<a name="cl-76"></a>        //! Constructs parse error
<a name="cl-77"></a>        parse_error(const char *what, void *where)
<a name="cl-78"></a>            : m_what(what)
<a name="cl-79"></a>            , m_where(where)
<a name="cl-80"></a>        {
<a name="cl-81"></a>        }
<a name="cl-82"></a>
<a name="cl-83"></a>        //! Gets human readable description of error.
<a name="cl-84"></a>        //! \return Pointer to null terminated description of the error.
<a name="cl-85"></a>        virtual const char *what() const throw()
<a name="cl-86"></a>        {
<a name="cl-87"></a>            return m_what;
<a name="cl-88"></a>        }
<a name="cl-89"></a>
<a name="cl-90"></a>        //! Gets pointer to character data where error happened.
<a name="cl-91"></a>        //! Ch should be the same as char type of xml_document that produced the error.
<a name="cl-92"></a>        //! \return Pointer to location within the parsed string where error occured.
<a name="cl-93"></a>        template&lt;class Ch&gt;
<a name="cl-94"></a>        Ch *where() const
<a name="cl-95"></a>        {
<a name="cl-96"></a>            return reinterpret_cast&lt;Ch *&gt;(m_where);
<a name="cl-97"></a>        }
<a name="cl-98"></a>
<a name="cl-99"></a>    private:  
<a name="cl-100"></a>
<a name="cl-101"></a>        const char *m_what;
<a name="cl-102"></a>        void *m_where;
<a name="cl-103"></a>
<a name="cl-104"></a>    };
<a name="cl-105"></a>}
<a name="cl-106"></a>
<a name="cl-107"></a>#endif
<a name="cl-108"></a>
<a name="cl-109"></a>///////////////////////////////////////////////////////////////////////////
<a name="cl-110"></a>// Pool sizes
<a name="cl-111"></a>
<a name="cl-112"></a>#ifndef RAPIDXML_STATIC_POOL_SIZE
<a name="cl-113"></a>    // Size of static memory block of memory_pool.
<a name="cl-114"></a>    // Define RAPIDXML_STATIC_POOL_SIZE before including rapidxml.hpp if you want to override the default value.
<a name="cl-115"></a>    // No dynamic memory allocations are performed by memory_pool until static memory is exhausted.
<a name="cl-116"></a>    #define RAPIDXML_STATIC_POOL_SIZE (64 * 1024)
<a name="cl-117"></a>#endif
<a name="cl-118"></a>
<a name="cl-119"></a>#ifndef RAPIDXML_DYNAMIC_POOL_SIZE
<a name="cl-120"></a>    // Size of dynamic memory block of memory_pool.
<a name="cl-121"></a>    // Define RAPIDXML_DYNAMIC_POOL_SIZE before including rapidxml.hpp if you want to override the default value.
<a name="cl-122"></a>    // After the static block is exhausted, dynamic blocks with approximately this size are allocated by memory_pool.
<a name="cl-123"></a>    #define RAPIDXML_DYNAMIC_POOL_SIZE (64 * 1024)
<a name="cl-124"></a>#endif
<a name="cl-125"></a>
<a name="cl-126"></a>#ifndef RAPIDXML_ALIGNMENT
<a name="cl-127"></a>    // Memory allocation alignment.
<a name="cl-128"></a>    // Define RAPIDXML_ALIGNMENT before including rapidxml.hpp if you want to override the default value, which is the size of pointer.
<a name="cl-129"></a>    // All memory allocations for nodes, attributes and strings will be aligned to this value.
<a name="cl-130"></a>    // This must be a power of 2 and at least 1, otherwise memory_pool will not work.
<a name="cl-131"></a>    #define RAPIDXML_ALIGNMENT sizeof(void *)
<a name="cl-132"></a>#endif
<a name="cl-133"></a>
<a name="cl-134"></a>namespace rapidxml
<a name="cl-135"></a>{
<a name="cl-136"></a>    // Forward declarations
<a name="cl-137"></a>    template&lt;class Ch&gt; class xml_node;
<a name="cl-138"></a>    template&lt;class Ch&gt; class xml_attribute;
<a name="cl-139"></a>    template&lt;class Ch&gt; class xml_document;
<a name="cl-140"></a>    
<a name="cl-141"></a>    //! Enumeration listing all node types produced by the parser.
<a name="cl-142"></a>    //! Use xml_node::type() function to query node type.
<a name="cl-143"></a>    enum node_type
<a name="cl-144"></a>    {
<a name="cl-145"></a>        node_document,      //!&lt; A document node. Name and value are empty.
<a name="cl-146"></a>        node_element,       //!&lt; An element node. Name contains element name. Value contains text of first data node.
<a name="cl-147"></a>        node_data,          //!&lt; A data node. Name is empty. Value contains data text.
<a name="cl-148"></a>        node_cdata,         //!&lt; A CDATA node. Name is empty. Value contains data text.
<a name="cl-149"></a>        node_comment,       //!&lt; A comment node. Name is empty. Value contains comment text.
<a name="cl-150"></a>        node_declaration,   //!&lt; A declaration node. Name and value are empty. Declaration parameters (version, encoding and standalone) are in node attributes.
<a name="cl-151"></a>        node_doctype,       //!&lt; A DOCTYPE node. Name is empty. Value contains DOCTYPE text.
<a name="cl-152"></a>        node_pi             //!&lt; A PI node. Name contains target. Value contains instructions.
<a name="cl-153"></a>    };
<a name="cl-154"></a>
<a name="cl-155"></a>    ///////////////////////////////////////////////////////////////////////
<a name="cl-156"></a>    // Parsing flags
<a name="cl-157"></a>
<a name="cl-158"></a>    //! Parse flag instructing the parser to not create data nodes. 
<a name="cl-159"></a>    //! Text of first data node will still be placed in value of parent element, unless rapidxml::parse_no_element_values flag is also specified.
<a name="cl-160"></a>    //! Can be combined with other flags by use of | operator.
<a name="cl-161"></a>    //! &lt;br&gt;&lt;br&gt;
<a name="cl-162"></a>    //! See xml_document::parse() function.
<a name="cl-163"></a>    const int parse_no_data_nodes = 0x1;            
<a name="cl-164"></a>
<a name="cl-165"></a>    //! Parse flag instructing the parser to not use text of first data node as a value of parent element.
<a name="cl-166"></a>    //! Can be combined with other flags by use of | operator.
<a name="cl-167"></a>    //! Note that child data nodes of element node take precendence over its value when printing. 
<a name="cl-168"></a>    //! That is, if element has one or more child data nodes &lt;em&gt;and&lt;/em&gt; a value, the value will be ignored.
<a name="cl-169"></a>    //! Use rapidxml::parse_no_data_nodes flag to prevent creation of data nodes if you want to manipulate data using values of elements.
<a name="cl-170"></a>    //! &lt;br&gt;&lt;br&gt;
<a name="cl-171"></a>    //! See xml_document::parse() function.
<a name="cl-172"></a>    const int parse_no_element_values = 0x2;
<a name="cl-173"></a>    
<a name="cl-174"></a>    //! Parse flag instructing the parser to not place zero terminators after strings in the source text.
<a name="cl-175"></a>    //! By default zero terminators are placed, modifying source text.
<a name="cl-176"></a>    //! Can be combined with other flags by use of | operator.
<a name="cl-177"></a>    //! &lt;br&gt;&lt;br&gt;
<a name="cl-178"></a>    //! See xml_document::parse() function.
<a name="cl-179"></a>    const int parse_no_string_terminators = 0x4;
<a name="cl-180"></a>    
<a name="cl-181"></a>    //! Parse flag instructing the parser to not translate entities in the source text.
<a name="cl-182"></a>    //! By default entities are translated, modifying source text.
<a name="cl-183"></a>    //! Can be combined with other flags by use of | operator.
<a name="cl-184"></a>    //! &lt;br&gt;&lt;br&gt;
<a name="cl-185"></a>    //! See xml_document::parse() function.
<a name="cl-186"></a>    const int parse_no_entity_translation = 0x8;
<a name="cl-187"></a>    
<a name="cl-188"></a>    //! Parse flag instructing the parser to disable UTF-8 handling and assume plain 8 bit characters.
<a name="cl-189"></a>    //! By default, UTF-8 handling is enabled.
<a name="cl-190"></a>    //! Can be combined with other flags by use of | operator.
<a name="cl-191"></a>    //! &lt;br&gt;&lt;br&gt;
<a name="cl-192"></a>    //! See xml_document::parse() function.
<a name="cl-193"></a>    const int parse_no_utf8 = 0x10;
<a name="cl-194"></a>    
<a name="cl-195"></a>    //! Parse flag instructing the parser to create XML declaration node.
<a name="cl-196"></a>    //! By default, declaration node is not created.
<a name="cl-197"></a>    //! Can be combined with other flags by use of | operator.
<a name="cl-198"></a>    //! &lt;br&gt;&lt;br&gt;
<a name="cl-199"></a>    //! See xml_document::parse() function.
<a name="cl-200"></a>    const int parse_declaration_node = 0x20;
<a name="cl-201"></a>    
<a name="cl-202"></a>    //! Parse flag instructing the parser to create comments nodes.
<a name="cl-203"></a>    //! By default, comment nodes are not created.
<a name="cl-204"></a>    //! Can be combined with other flags by use of | operator.
<a name="cl-205"></a>    //! &lt;br&gt;&lt;br&gt;
<a name="cl-206"></a>    //! See xml_document::parse() function.
<a name="cl-207"></a>    const int parse_comment_nodes = 0x40;
<a name="cl-208"></a>    
<a name="cl-209"></a>    //! Parse flag instructing the parser to create DOCTYPE node.
<a name="cl-210"></a>    //! By default, doctype node is not created.
<a name="cl-211"></a>    //! Although W3C specification allows at most one DOCTYPE node, RapidXml will silently accept documents with more than one.
<a name="cl-212"></a>    //! Can be combined with other flags by use of | operator.
<a name="cl-213"></a>    //! &lt;br&gt;&lt;br&gt;
<a name="cl-214"></a>    //! See xml_document::parse() function.
<a name="cl-215"></a>    const int parse_doctype_node = 0x80;
<a name="cl-216"></a>    
<a name="cl-217"></a>    //! Parse flag instructing the parser to create PI nodes.
<a name="cl-218"></a>    //! By default, PI nodes are not created.
<a name="cl-219"></a>    //! Can be combined with other flags by use of | operator.
<a name="cl-220"></a>    //! &lt;br&gt;&lt;br&gt;
<a name="cl-221"></a>    //! See xml_document::parse() function.
<a name="cl-222"></a>    const int parse_pi_nodes = 0x100;
<a name="cl-223"></a>    
<a name="cl-224"></a>    //! Parse flag instructing the parser to validate closing tag names. 
<a name="cl-225"></a>    //! If not set, name inside closing tag is irrelevant to the parser.
<a name="cl-226"></a>    //! By default, closing tags are not validated.
<a name="cl-227"></a>    //! Can be combined with other flags by use of | operator.
<a name="cl-228"></a>    //! &lt;br&gt;&lt;br&gt;
<a name="cl-229"></a>    //! See xml_document::parse() function.
<a name="cl-230"></a>    const int parse_validate_closing_tags = 0x200;
<a name="cl-231"></a>    
<a name="cl-232"></a>    //! Parse flag instructing the parser to trim all leading and trailing whitespace of data nodes.
<a name="cl-233"></a>    //! By default, whitespace is not trimmed. 
<a name="cl-234"></a>    //! This flag does not cause the parser to modify source text.
<a name="cl-235"></a>    //! Can be combined with other flags by use of | operator.
<a name="cl-236"></a>    //! &lt;br&gt;&lt;br&gt;
<a name="cl-237"></a>    //! See xml_document::parse() function.
<a name="cl-238"></a>    const int parse_trim_whitespace = 0x400;
<a name="cl-239"></a>
<a name="cl-240"></a>    //! Parse flag instructing the parser to condense all whitespace runs of data nodes to a single space character.
<a name="cl-241"></a>    //! Trimming of leading and trailing whitespace of data is controlled by rapidxml::parse_trim_whitespace flag.
<a name="cl-242"></a>    //! By default, whitespace is not normalized. 
<a name="cl-243"></a>    //! If this flag is specified, source text will be modified.
<a name="cl-244"></a>    //! Can be combined with other flags by use of | operator.
<a name="cl-245"></a>    //! &lt;br&gt;&lt;br&gt;
<a name="cl-246"></a>    //! See xml_document::parse() function.
<a name="cl-247"></a>    const int parse_normalize_whitespace = 0x800;
<a name="cl-248"></a>
<a name="cl-249"></a>    // Compound flags
<a name="cl-250"></a>    
<a name="cl-251"></a>    //! Parse flags which represent default behaviour of the parser. 
<a name="cl-252"></a>    //! This is always equal to 0, so that all other flags can be simply ored together.
<a name="cl-253"></a>    //! Normally there is no need to inconveniently disable flags by anding with their negated (~) values.
<a name="cl-254"></a>    //! This also means that meaning of each flag is a &lt;i&gt;negation&lt;/i&gt; of the default setting. 
<a name="cl-255"></a>    //! For example, if flag name is rapidxml::parse_no_utf8, it means that utf-8 is &lt;i&gt;enabled&lt;/i&gt; by default,
<a name="cl-256"></a>    //! and using the flag will disable it.
<a name="cl-257"></a>    //! &lt;br&gt;&lt;br&gt;
<a name="cl-258"></a>    //! See xml_document::parse() function.
<a name="cl-259"></a>    const int parse_default = 0;
<a name="cl-260"></a>    
<a name="cl-261"></a>    //! A combination of parse flags that forbids any modifications of the source text. 
<a name="cl-262"></a>    //! This also results in faster parsing. However, note that the following will occur:
<a name="cl-263"></a>    //! &lt;ul&gt;
<a name="cl-264"></a>    //! &lt;li&gt;names and values of nodes will not be zero terminated, you have to use xml_base::name_size() and xml_base::value_size() functions to determine where name and value ends&lt;/li&gt;
<a name="cl-265"></a>    //! &lt;li&gt;entities will not be translated&lt;/li&gt;
<a name="cl-266"></a>    //! &lt;li&gt;whitespace will not be normalized&lt;/li&gt;
<a name="cl-267"></a>    //! &lt;/ul&gt;
<a name="cl-268"></a>    //! See xml_document::parse() function.
<a name="cl-269"></a>    const int parse_non_destructive = parse_no_string_terminators | parse_no_entity_translation;
<a name="cl-270"></a>    
<a name="cl-271"></a>    //! A combination of parse flags resulting in fastest possible parsing, without sacrificing important data.
<a name="cl-272"></a>    //! &lt;br&gt;&lt;br&gt;
<a name="cl-273"></a>    //! See xml_document::parse() function.
<a name="cl-274"></a>    const int parse_fastest = parse_non_destructive | parse_no_data_nodes;
<a name="cl-275"></a>    
<a name="cl-276"></a>    //! A combination of parse flags resulting in largest amount of data being extracted. 
<a name="cl-277"></a>    //! This usually results in slowest parsing.
<a name="cl-278"></a>    //! &lt;br&gt;&lt;br&gt;
<a name="cl-279"></a>    //! See xml_document::parse() function.
<a name="cl-280"></a>    const int parse_full = parse_declaration_node | parse_comment_nodes | parse_doctype_node | parse_pi_nodes | parse_validate_closing_tags;
<a name="cl-281"></a>
<a name="cl-282"></a>    ///////////////////////////////////////////////////////////////////////
<a name="cl-283"></a>    // Internals
<a name="cl-284"></a>
<a name="cl-285"></a>    //! \cond internal
<a name="cl-286"></a>    namespace internal
<a name="cl-287"></a>    {
<a name="cl-288"></a>
<a name="cl-289"></a>        // Struct that contains lookup tables for the parser
<a name="cl-290"></a>        // It must be a template to allow correct linking (because it has static data members, which are defined in a header file).
<a name="cl-291"></a>        template&lt;int Dummy&gt;
<a name="cl-292"></a>        struct lookup_tables
<a name="cl-293"></a>        {
<a name="cl-294"></a>            static const unsigned char lookup_whitespace[256];              // Whitespace table
<a name="cl-295"></a>            static const unsigned char lookup_node_name[256];               // Node name table
<a name="cl-296"></a>            static const unsigned char lookup_text[256];                    // Text table
<a name="cl-297"></a>            static const unsigned char lookup_text_pure_no_ws[256];         // Text table
<a name="cl-298"></a>            static const unsigned char lookup_text_pure_with_ws[256];       // Text table
<a name="cl-299"></a>            static const unsigned char lookup_attribute_name[256];          // Attribute name table
<a name="cl-300"></a>            static const unsigned char lookup_attribute_data_1[256];        // Attribute data table with single quote
<a name="cl-301"></a>            static const unsigned char lookup_attribute_data_1_pure[256];   // Attribute data table with single quote
<a name="cl-302"></a>            static const unsigned char lookup_attribute_data_2[256];        // Attribute data table with double quotes
<a name="cl-303"></a>            static const unsigned char lookup_attribute_data_2_pure[256];   // Attribute data table with double quotes
<a name="cl-304"></a>            static const unsigned char lookup_digits[256];                  // Digits
<a name="cl-305"></a>            static const unsigned char lookup_upcase[256];                  // To uppercase conversion table for ASCII characters
<a name="cl-306"></a>        };
<a name="cl-307"></a>
<a name="cl-308"></a>        // Find length of the string
<a name="cl-309"></a>        template&lt;class Ch&gt;
<a name="cl-310"></a>        inline std::size_t measure(const Ch *p)
<a name="cl-311"></a>        {
<a name="cl-312"></a>            const Ch *tmp = p;
<a name="cl-313"></a>            while (*tmp) 
<a name="cl-314"></a>                ++tmp;
<a name="cl-315"></a>            return tmp - p;
<a name="cl-316"></a>        }
<a name="cl-317"></a>
<a name="cl-318"></a>        // Compare strings for equality
<a name="cl-319"></a>        template&lt;class Ch&gt;
<a name="cl-320"></a>        inline bool compare(const Ch *p1, std::size_t size1, const Ch *p2, std::size_t size2, bool case_sensitive)
<a name="cl-321"></a>        {
<a name="cl-322"></a>            if (size1 != size2)
<a name="cl-323"></a>                return false;
<a name="cl-324"></a>            if (case_sensitive)
<a name="cl-325"></a>            {
<a name="cl-326"></a>                for (const Ch *end = p1 + size1; p1 &lt; end; ++p1, ++p2)
<a name="cl-327"></a>                    if (*p1 != *p2)
<a name="cl-328"></a>                        return false;
<a name="cl-329"></a>            }
<a name="cl-330"></a>            else
<a name="cl-331"></a>            {
<a name="cl-332"></a>                for (const Ch *end = p1 + size1; p1 &lt; end; ++p1, ++p2)
<a name="cl-333"></a>                    if (lookup_tables&lt;0&gt;::lookup_upcase[static_cast&lt;unsigned char&gt;(*p1)] != lookup_tables&lt;0&gt;::lookup_upcase[static_cast&lt;unsigned char&gt;(*p2)])
<a name="cl-334"></a>                        return false;
<a name="cl-335"></a>            }
<a name="cl-336"></a>            return true;
<a name="cl-337"></a>        }
<a name="cl-338"></a>    }
<a name="cl-339"></a>    //! \endcond
<a name="cl-340"></a>
<a name="cl-341"></a>    ///////////////////////////////////////////////////////////////////////
<a name="cl-342"></a>    // Memory pool
<a name="cl-343"></a>    
<a name="cl-344"></a>    //! This class is used by the parser to create new nodes and attributes, without overheads of dynamic memory allocation.
<a name="cl-345"></a>    //! In most cases, you will not need to use this class directly. 
<a name="cl-346"></a>    //! However, if you need to create nodes manually or modify names/values of nodes, 
<a name="cl-347"></a>    //! you are encouraged to use memory_pool of relevant xml_document to allocate the memory. 
<a name="cl-348"></a>    //! Not only is this faster than allocating them by using &lt;code&gt;new&lt;/code&gt; operator, 
<a name="cl-349"></a>    //! but also their lifetime will be tied to the lifetime of document, 
<a name="cl-350"></a>    //! possibly simplyfing memory management. 
<a name="cl-351"></a>    //! &lt;br&gt;&lt;br&gt;
<a name="cl-352"></a>    //! Call allocate_node() or allocate_attribute() functions to obtain new nodes or attributes from the pool. 
<a name="cl-353"></a>    //! You can also call allocate_string() function to allocate strings.
<a name="cl-354"></a>    //! Such strings can then be used as names or values of nodes without worrying about their lifetime.
<a name="cl-355"></a>    //! Note that there is no &lt;code&gt;free()&lt;/code&gt; function -- all allocations are freed at once when clear() function is called, 
<a name="cl-356"></a>    //! or when the pool is destroyed.
<a name="cl-357"></a>    //! &lt;br&gt;&lt;br&gt;
<a name="cl-358"></a>    //! It is also possible to create a standalone memory_pool, and use it 
<a name="cl-359"></a>    //! to allocate nodes, whose lifetime will not be tied to any document.
<a name="cl-360"></a>    //! &lt;br&gt;&lt;br&gt;
<a name="cl-361"></a>    //! Pool maintains &lt;code&gt;RAPIDXML_STATIC_POOL_SIZE&lt;/code&gt; bytes of statically allocated memory. 
<a name="cl-362"></a>    //! Until static memory is exhausted, no dynamic memory allocations are done.
<a name="cl-363"></a>    //! When static memory is exhausted, pool allocates additional blocks of memory of size &lt;code&gt;RAPIDXML_DYNAMIC_POOL_SIZE&lt;/code&gt; each,
<a name="cl-364"></a>    //! by using global &lt;code&gt;new[]&lt;/code&gt; and &lt;code&gt;delete[]&lt;/code&gt; operators. 
<a name="cl-365"></a>    //! This behaviour can be changed by setting custom allocation routines. 
<a name="cl-366"></a>    //! Use set_allocator() function to set them.
<a name="cl-367"></a>    //! &lt;br&gt;&lt;br&gt;
<a name="cl-368"></a>    //! Allocations for nodes, attributes and strings are aligned at &lt;code&gt;RAPIDXML_ALIGNMENT&lt;/code&gt; bytes.
<a name="cl-369"></a>    //! This value defaults to the size of pointer on target architecture.
<a name="cl-370"></a>    //! &lt;br&gt;&lt;br&gt;
<a name="cl-371"></a>    //! To obtain absolutely top performance from the parser,
<a name="cl-372"></a>    //! it is important that all nodes are allocated from a single, contiguous block of memory.
<a name="cl-373"></a>    //! Otherwise, cache misses when jumping between two (or more) disjoint blocks of memory can slow down parsing quite considerably.
<a name="cl-374"></a>    //! If required, you can tweak &lt;code&gt;RAPIDXML_STATIC_POOL_SIZE&lt;/code&gt;, &lt;code&gt;RAPIDXML_DYNAMIC_POOL_SIZE&lt;/code&gt; and &lt;code&gt;RAPIDXML_ALIGNMENT&lt;/code&gt; 
<a name="cl-375"></a>    //! to obtain best wasted memory to performance compromise.
<a name="cl-376"></a>    //! To do it, define their values before rapidxml.hpp file is included.
<a name="cl-377"></a>    //! \param Ch Character type of created nodes. 
<a name="cl-378"></a>    template&lt;class Ch = char&gt;
<a name="cl-379"></a>    class memory_pool
<a name="cl-380"></a>    {
<a name="cl-381"></a>        
<a name="cl-382"></a>    public:
<a name="cl-383"></a>
<a name="cl-384"></a>        //! \cond internal
<a name="cl-385"></a>        typedef void *(alloc_func)(std::size_t);       // Type of user-defined function used to allocate memory
<a name="cl-386"></a>        typedef void (free_func)(void *);              // Type of user-defined function used to free memory
<a name="cl-387"></a>        //! \endcond
<a name="cl-388"></a>        
<a name="cl-389"></a>        //! Constructs empty pool with default allocator functions.
<a name="cl-390"></a>        memory_pool()
<a name="cl-391"></a>            : m_alloc_func(0)
<a name="cl-392"></a>            , m_free_func(0)
<a name="cl-393"></a>        {
<a name="cl-394"></a>            init();
<a name="cl-395"></a>        }
<a name="cl-396"></a>
<a name="cl-397"></a>        //! Destroys pool and frees all the memory. 
<a name="cl-398"></a>        //! This causes memory occupied by nodes allocated by the pool to be freed.
<a name="cl-399"></a>        //! Nodes allocated from the pool are no longer valid.
<a name="cl-400"></a>        ~memory_pool()
<a name="cl-401"></a>        {
<a name="cl-402"></a>            clear();
<a name="cl-403"></a>        }
<a name="cl-404"></a>
<a name="cl-405"></a>        //! Allocates a new node from the pool, and optionally assigns name and value to it. 
<a name="cl-406"></a>        //! If the allocation request cannot be accomodated, this function will throw &lt;code&gt;std::bad_alloc&lt;/code&gt;.
<a name="cl-407"></a>        //! If exceptions are disabled by defining RAPIDXML_NO_EXCEPTIONS, this function
<a name="cl-408"></a>        //! will call rapidxml::parse_error_handler() function.
<a name="cl-409"></a>        //! \param type Type of node to create.
<a name="cl-410"></a>        //! \param name Name to assign to the node, or 0 to assign no name.
<a name="cl-411"></a>        //! \param value Value to assign to the node, or 0 to assign no value.
<a name="cl-412"></a>        //! \param name_size Size of name to assign, or 0 to automatically calculate size from name string.
<a name="cl-413"></a>        //! \param value_size Size of value to assign, or 0 to automatically calculate size from value string.
<a name="cl-414"></a>        //! \return Pointer to allocated node. This pointer will never be NULL.
<a name="cl-415"></a>        xml_node&lt;Ch&gt; *allocate_node(node_type type, 
<a name="cl-416"></a>                                    const Ch *name = 0, const Ch *value = 0, 
<a name="cl-417"></a>                                    std::size_t name_size = 0, std::size_t value_size = 0)
<a name="cl-418"></a>        {
<a name="cl-419"></a>            void *memory = allocate_aligned(sizeof(xml_node&lt;Ch&gt;));
<a name="cl-420"></a>            xml_node&lt;Ch&gt; *node = new(memory) xml_node&lt;Ch&gt;(type);
<a name="cl-421"></a>            if (name)
<a name="cl-422"></a>            {
<a name="cl-423"></a>                if (name_size &gt; 0)
<a name="cl-424"></a>                    node-&gt;name(name, name_size);
<a name="cl-425"></a>                else
<a name="cl-426"></a>                    node-&gt;name(name);
<a name="cl-427"></a>            }
<a name="cl-428"></a>            if (value)
<a name="cl-429"></a>            {
<a name="cl-430"></a>                if (value_size &gt; 0)
<a name="cl-431"></a>                    node-&gt;value(value, value_size);
<a name="cl-432"></a>                else
<a name="cl-433"></a>                    node-&gt;value(value);
<a name="cl-434"></a>            }
<a name="cl-435"></a>            return node;
<a name="cl-436"></a>        }
<a name="cl-437"></a>
<a name="cl-438"></a>        //! Allocates a new attribute from the pool, and optionally assigns name and value to it.
<a name="cl-439"></a>        //! If the allocation request cannot be accomodated, this function will throw &lt;code&gt;std::bad_alloc&lt;/code&gt;.
<a name="cl-440"></a>        //! If exceptions are disabled by defining RAPIDXML_NO_EXCEPTIONS, this function
<a name="cl-441"></a>        //! will call rapidxml::parse_error_handler() function.
<a name="cl-442"></a>        //! \param name Name to assign to the attribute, or 0 to assign no name.
<a name="cl-443"></a>        //! \param value Value to assign to the attribute, or 0 to assign no value.
<a name="cl-444"></a>        //! \param name_size Size of name to assign, or 0 to automatically calculate size from name string.
<a name="cl-445"></a>        //! \param value_size Size of value to assign, or 0 to automatically calculate size from value string.
<a name="cl-446"></a>        //! \return Pointer to allocated attribute. This pointer will never be NULL.
<a name="cl-447"></a>        xml_attribute&lt;Ch&gt; *allocate_attribute(const Ch *name = 0, const Ch *value = 0, 
<a name="cl-448"></a>                                              std::size_t name_size = 0, std::size_t value_size = 0)
<a name="cl-449"></a>        {
<a name="cl-450"></a>            void *memory = allocate_aligned(sizeof(xml_attribute&lt;Ch&gt;));
<a name="cl-451"></a>            xml_attribute&lt;Ch&gt; *attribute = new(memory) xml_attribute&lt;Ch&gt;;
<a name="cl-452"></a>            if (name)
<a name="cl-453"></a>            {
<a name="cl-454"></a>                if (name_size &gt; 0)
<a name="cl-455"></a>                    attribute-&gt;name(name, name_size);
<a name="cl-456"></a>                else
<a name="cl-457"></a>                    attribute-&gt;name(name);
<a name="cl-458"></a>            }
<a name="cl-459"></a>            if (value)
<a name="cl-460"></a>            {
<a name="cl-461"></a>                if (value_size &gt; 0)
<a name="cl-462"></a>                    attribute-&gt;value(value, value_size);
<a name="cl-463"></a>                else
<a name="cl-464"></a>                    attribute-&gt;value(value);
<a name="cl-465"></a>            }
<a name="cl-466"></a>            return attribute;
<a name="cl-467"></a>        }
<a name="cl-468"></a>
<a name="cl-469"></a>        //! Allocates a char array of given size from the pool, and optionally copies a given string to it.
<a name="cl-470"></a>        //! If the allocation request cannot be accomodated, this function will throw &lt;code&gt;std::bad_alloc&lt;/code&gt;.
<a name="cl-471"></a>        //! If exceptions are disabled by defining RAPIDXML_NO_EXCEPTIONS, this function
<a name="cl-472"></a>        //! will call rapidxml::parse_error_handler() function.
<a name="cl-473"></a>        //! \param source String to initialize the allocated memory with, or 0 to not initialize it.
<a name="cl-474"></a>        //! \param size Number of characters to allocate, or zero to calculate it automatically from source string length; if size is 0, source string must be specified and null terminated.
<a name="cl-475"></a>        //! \return Pointer to allocated char array. This pointer will never be NULL.
<a name="cl-476"></a>        Ch *allocate_string(const Ch *source = 0, std::size_t size = 0)
<a name="cl-477"></a>        {
<a name="cl-478"></a>            assert(source || size);     // Either source or size (or both) must be specified
<a name="cl-479"></a>            if (size == 0)
<a name="cl-480"></a>                size = internal::measure(source) + 1;
<a name="cl-481"></a>            Ch *result = static_cast&lt;Ch *&gt;(allocate_aligned(size * sizeof(Ch)));
<a name="cl-482"></a>            if (source)
<a name="cl-483"></a>                for (std::size_t i = 0; i &lt; size; ++i)
<a name="cl-484"></a>                    result[i] = source[i];
<a name="cl-485"></a>            return result;
<a name="cl-486"></a>        }
<a name="cl-487"></a>
<a name="cl-488"></a>        //! Clones an xml_node and its hierarchy of child nodes and attributes.
<a name="cl-489"></a>        //! Nodes and attributes are allocated from this memory pool.
<a name="cl-490"></a>        //! Names and values are not cloned, they are shared between the clone and the source.
<a name="cl-491"></a>        //! Result node can be optionally specified as a second parameter, 
<a name="cl-492"></a>        //! in which case its contents will be replaced with cloned source node.
<a name="cl-493"></a>        //! This is useful when you want to clone entire document.
<a name="cl-494"></a>        //! \param source Node to clone.
<a name="cl-495"></a>        //! \param result Node to put results in, or 0 to automatically allocate result node
<a name="cl-496"></a>        //! \return Pointer to cloned node. This pointer will never be NULL.
<a name="cl-497"></a>        xml_node&lt;Ch&gt; *clone_node(const xml_node&lt;Ch&gt; *source, xml_node&lt;Ch&gt; *result = 0)
<a name="cl-498"></a>        {
<a name="cl-499"></a>            // Prepare result node
<a name="cl-500"></a>            if (result)
<a name="cl-501"></a>            {
<a name="cl-502"></a>                result-&gt;remove_all_attributes();
<a name="cl-503"></a>                result-&gt;remove_all_nodes();
<a name="cl-504"></a>                result-&gt;type(source-&gt;type());
<a name="cl-505"></a>            }
<a name="cl-506"></a>            else
<a name="cl-507"></a>                result = allocate_node(source-&gt;type());
<a name="cl-508"></a>
<a name="cl-509"></a>            // Clone name and value
<a name="cl-510"></a>            result-&gt;name(source-&gt;name(), source-&gt;name_size());
<a name="cl-511"></a>            result-&gt;value(source-&gt;value(), source-&gt;value_size());
<a name="cl-512"></a>
<a name="cl-513"></a>            // Clone child nodes and attributes
<a name="cl-514"></a>            for (xml_node&lt;Ch&gt; *child = source-&gt;first_node(); child; child = child-&gt;next_sibling())
<a name="cl-515"></a>                result-&gt;append_node(clone_node(child));
<a name="cl-516"></a>            for (xml_attribute&lt;Ch&gt; *attr = source-&gt;first_attribute(); attr; attr = attr-&gt;next_attribute())
<a name="cl-517"></a>                result-&gt;append_attribute(allocate_attribute(attr-&gt;name(), attr-&gt;value(), attr-&gt;name_size(), attr-&gt;value_size()));
<a name="cl-518"></a>
<a name="cl-519"></a>            return result;
<a name="cl-520"></a>        }
<a name="cl-521"></a>
<a name="cl-522"></a>        //! Clears the pool. 
<a name="cl-523"></a>        //! This causes memory occupied by nodes allocated by the pool to be freed.
<a name="cl-524"></a>        //! Any nodes or strings allocated from the pool will no longer be valid.
<a name="cl-525"></a>        void clear()
<a name="cl-526"></a>        {
<a name="cl-527"></a>            while (m_begin != m_static_memory)
<a name="cl-528"></a>            {
<a name="cl-529"></a>                char *previous_begin = reinterpret_cast&lt;header *&gt;(align(m_begin))-&gt;previous_begin;
<a name="cl-530"></a>                if (m_free_func)
<a name="cl-531"></a>                    m_free_func(m_begin);
<a name="cl-532"></a>                else
<a name="cl-533"></a>                    delete[] m_begin;
<a name="cl-534"></a>                m_begin = previous_begin;
<a name="cl-535"></a>            }
<a name="cl-536"></a>            init();
<a name="cl-537"></a>        }
<a name="cl-538"></a>
<a name="cl-539"></a>        //! Sets or resets the user-defined memory allocation functions for the pool.
<a name="cl-540"></a>        //! This can only be called when no memory is allocated from the pool yet, otherwise results are undefined.
<a name="cl-541"></a>        //! Allocation function must not return invalid pointer on failure. It should either throw,
<a name="cl-542"></a>        //! stop the program, or use &lt;code&gt;longjmp()&lt;/code&gt; function to pass control to other place of program. 
<a name="cl-543"></a>        //! If it returns invalid pointer, results are undefined.
<a name="cl-544"></a>        //! &lt;br&gt;&lt;br&gt;
<a name="cl-545"></a>        //! User defined allocation functions must have the following forms:
<a name="cl-546"></a>        //! &lt;br&gt;&lt;code&gt;
<a name="cl-547"></a>        //! &lt;br&gt;void *allocate(std::size_t size);
<a name="cl-548"></a>        //! &lt;br&gt;void free(void *pointer);
<a name="cl-549"></a>        //! &lt;/code&gt;&lt;br&gt;
<a name="cl-550"></a>        //! \param af Allocation function, or 0 to restore default function
<a name="cl-551"></a>        //! \param ff Free function, or 0 to restore default function
<a name="cl-552"></a>        void set_allocator(alloc_func *af, free_func *ff)
<a name="cl-553"></a>        {
<a name="cl-554"></a>            assert(m_begin == m_static_memory &amp;&amp; m_ptr == align(m_begin));    // Verify that no memory is allocated yet
<a name="cl-555"></a>            m_alloc_func = af;
<a name="cl-556"></a>            m_free_func = ff;
<a name="cl-557"></a>        }
<a name="cl-558"></a>
<a name="cl-559"></a>    private:
<a name="cl-560"></a>
<a name="cl-561"></a>        struct header
<a name="cl-562"></a>        {
<a name="cl-563"></a>            char *previous_begin;
<a name="cl-564"></a>        };
<a name="cl-565"></a>
<a name="cl-566"></a>        void init()
<a name="cl-567"></a>        {
<a name="cl-568"></a>            m_begin = m_static_memory;
<a name="cl-569"></a>            m_ptr = align(m_begin);
<a name="cl-570"></a>            m_end = m_static_memory + sizeof(m_static_memory);
<a name="cl-571"></a>        }
<a name="cl-572"></a>        
<a name="cl-573"></a>        char *align(char *ptr)
<a name="cl-574"></a>        {
<a name="cl-575"></a>            std::size_t alignment = ((RAPIDXML_ALIGNMENT - (std::size_t(ptr) &amp; (RAPIDXML_ALIGNMENT - 1))) &amp; (RAPIDXML_ALIGNMENT - 1));
<a name="cl-576"></a>            return ptr + alignment;
<a name="cl-577"></a>        }
<a name="cl-578"></a>        
<a name="cl-579"></a>        char *allocate_raw(std::size_t size)
<a name="cl-580"></a>        {
<a name="cl-581"></a>            // Allocate
<a name="cl-582"></a>            void *memory;   
<a name="cl-583"></a>            if (m_alloc_func)   // Allocate memory using either user-specified allocation function or global operator new[]
<a name="cl-584"></a>            {
<a name="cl-585"></a>                memory = m_alloc_func(size);
<a name="cl-586"></a>                assert(memory); // Allocator is not allowed to return 0, on failure it must either throw, stop the program or use longjmp
<a name="cl-587"></a>            }
<a name="cl-588"></a>            else
<a name="cl-589"></a>            {
<a name="cl-590"></a>                memory = new char[size];
<a name="cl-591"></a>#ifdef RAPIDXML_NO_EXCEPTIONS
<a name="cl-592"></a>                if (!memory)            // If exceptions are disabled, verify memory allocation, because new will not be able to throw bad_alloc
<a name="cl-593"></a>                    RAPIDXML_PARSE_ERROR("out of memory", 0);
<a name="cl-594"></a>#endif
<a name="cl-595"></a>            }
<a name="cl-596"></a>            return static_cast&lt;char *&gt;(memory);
<a name="cl-597"></a>        }
<a name="cl-598"></a>        
<a name="cl-599"></a>        void *allocate_aligned(std::size_t size)
<a name="cl-600"></a>        {
<a name="cl-601"></a>            // Calculate aligned pointer
<a name="cl-602"></a>            char *result = align(m_ptr);
<a name="cl-603"></a>
<a name="cl-604"></a>            // If not enough memory left in current pool, allocate a new pool
<a name="cl-605"></a>            if (result + size &gt; m_end)
<a name="cl-606"></a>            {
<a name="cl-607"></a>                // Calculate required pool size (may be bigger than RAPIDXML_DYNAMIC_POOL_SIZE)
<a name="cl-608"></a>                std::size_t pool_size = RAPIDXML_DYNAMIC_POOL_SIZE;
<a name="cl-609"></a>                if (pool_size &lt; size)
<a name="cl-610"></a>                    pool_size = size;
<a name="cl-611"></a>                
<a name="cl-612"></a>                // Allocate
<a name="cl-613"></a>                std::size_t alloc_size = sizeof(header) + (2 * RAPIDXML_ALIGNMENT - 2) + pool_size;     // 2 alignments required in worst case: one for header, one for actual allocation
<a name="cl-614"></a>                char *raw_memory = allocate_raw(alloc_size);
<a name="cl-615"></a>                    
<a name="cl-616"></a>                // Setup new pool in allocated memory
<a name="cl-617"></a>                char *pool = align(raw_memory);
<a name="cl-618"></a>                header *new_header = reinterpret_cast&lt;header *&gt;(pool);
<a name="cl-619"></a>                new_header-&gt;previous_begin = m_begin;
<a name="cl-620"></a>                m_begin = raw_memory;
<a name="cl-621"></a>                m_ptr = pool + sizeof(header);
<a name="cl-622"></a>                m_end = raw_memory + alloc_size;
<a name="cl-623"></a>
<a name="cl-624"></a>                // Calculate aligned pointer again using new pool
<a name="cl-625"></a>                result = align(m_ptr);
<a name="cl-626"></a>            }
<a name="cl-627"></a>
<a name="cl-628"></a>            // Update pool and return aligned pointer
<a name="cl-629"></a>            m_ptr = result + size;
<a name="cl-630"></a>            return result;
<a name="cl-631"></a>        }
<a name="cl-632"></a>
<a name="cl-633"></a>        char *m_begin;                                      // Start of raw memory making up current pool
<a name="cl-634"></a>        char *m_ptr;                                        // First free byte in current pool
<a name="cl-635"></a>        char *m_end;                                        // One past last available byte in current pool
<a name="cl-636"></a>        char m_static_memory[RAPIDXML_STATIC_POOL_SIZE];    // Static raw memory
<a name="cl-637"></a>        alloc_func *m_alloc_func;                           // Allocator function, or 0 if default is to be used
<a name="cl-638"></a>        free_func *m_free_func;                             // Free function, or 0 if default is to be used
<a name="cl-639"></a>    };
<a name="cl-640"></a>
<a name="cl-641"></a>    ///////////////////////////////////////////////////////////////////////////
<a name="cl-642"></a>    // XML base
<a name="cl-643"></a>
<a name="cl-644"></a>    //! Base class for xml_node and xml_attribute implementing common functions: 
<a name="cl-645"></a>    //! name(), name_size(), value(), value_size() and parent().
<a name="cl-646"></a>    //! \param Ch Character type to use
<a name="cl-647"></a>    template&lt;class Ch = char&gt;
<a name="cl-648"></a>    class xml_base
<a name="cl-649"></a>    {
<a name="cl-650"></a>
<a name="cl-651"></a>    public:
<a name="cl-652"></a>        
<a name="cl-653"></a>        ///////////////////////////////////////////////////////////////////////////
<a name="cl-654"></a>        // Construction &amp; destruction
<a name="cl-655"></a>    
<a name="cl-656"></a>        // Construct a base with empty name, value and parent
<a name="cl-657"></a>        xml_base()
<a name="cl-658"></a>            : m_name(0)
<a name="cl-659"></a>            , m_value(0)
<a name="cl-660"></a>            , m_parent(0)
<a name="cl-661"></a>        {
<a name="cl-662"></a>        }
<a name="cl-663"></a>
<a name="cl-664"></a>        ///////////////////////////////////////////////////////////////////////////
<a name="cl-665"></a>        // Node data access
<a name="cl-666"></a>    
<a name="cl-667"></a>        //! Gets name of the node. 
<a name="cl-668"></a>        //! Interpretation of name depends on type of node.
<a name="cl-669"></a>        //! Note that name will not be zero-terminated if rapidxml::parse_no_string_terminators option was selected during parse.
<a name="cl-670"></a>        //! &lt;br&gt;&lt;br&gt;
<a name="cl-671"></a>        //! Use name_size() function to determine length of the name.
<a name="cl-672"></a>        //! \return Name of node, or empty string if node has no name.
<a name="cl-673"></a>        Ch *name() const
<a name="cl-674"></a>        {
<a name="cl-675"></a>            return m_name ? m_name : nullstr();
<a name="cl-676"></a>        }
<a name="cl-677"></a>
<a name="cl-678"></a>        //! Gets size of node name, not including terminator character.
<a name="cl-679"></a>        //! This function works correctly irrespective of whether name is or is not zero terminated.
<a name="cl-680"></a>        //! \return Size of node name, in characters.
<a name="cl-681"></a>        std::size_t name_size() const
<a name="cl-682"></a>        {
<a name="cl-683"></a>            return m_name ? m_name_size : 0;
<a name="cl-684"></a>        }
<a name="cl-685"></a>
<a name="cl-686"></a>        //! Gets value of node. 
<a name="cl-687"></a>        //! Interpretation of value depends on type of node.
<a name="cl-688"></a>        //! Note that value will not be zero-terminated if rapidxml::parse_no_string_terminators option was selected during parse.
<a name="cl-689"></a>        //! &lt;br&gt;&lt;br&gt;
<a name="cl-690"></a>        //! Use value_size() function to determine length of the value.
<a name="cl-691"></a>        //! \return Value of node, or empty string if node has no value.
<a name="cl-692"></a>        Ch *value() const
<a name="cl-693"></a>        {
<a name="cl-694"></a>            return m_value ? m_value : nullstr();
<a name="cl-695"></a>        }
<a name="cl-696"></a>
<a name="cl-697"></a>        //! Gets size of node value, not including terminator character.
<a name="cl-698"></a>        //! This function works correctly irrespective of whether value is or is not zero terminated.
<a name="cl-699"></a>        //! \return Size of node value, in characters.
<a name="cl-700"></a>        std::size_t value_size() const
<a name="cl-701"></a>        {
<a name="cl-702"></a>            return m_value ? m_value_size : 0;
<a name="cl-703"></a>        }
<a name="cl-704"></a>
<a name="cl-705"></a>        ///////////////////////////////////////////////////////////////////////////
<a name="cl-706"></a>        // Node modification
<a name="cl-707"></a>    
<a name="cl-708"></a>        //! Sets name of node to a non zero-terminated string.
<a name="cl-709"></a>        //! See \ref ownership_of_strings.
<a name="cl-710"></a>        //! &lt;br&gt;&lt;br&gt;
<a name="cl-711"></a>        //! Note that node does not own its name or value, it only stores a pointer to it. 
<a name="cl-712"></a>        //! It will not delete or otherwise free the pointer on destruction.
<a name="cl-713"></a>        //! It is reponsibility of the user to properly manage lifetime of the string.
<a name="cl-714"></a>        //! The easiest way to achieve it is to use memory_pool of the document to allocate the string -
<a name="cl-715"></a>        //! on destruction of the document the string will be automatically freed.
<a name="cl-716"></a>        //! &lt;br&gt;&lt;br&gt;
<a name="cl-717"></a>        //! Size of name must be specified separately, because name does not have to be zero terminated.
<a name="cl-718"></a>        //! Use name(const Ch *) function to have the length automatically calculated (string must be zero terminated).
<a name="cl-719"></a>        //! \param name Name of node to set. Does not have to be zero terminated.
<a name="cl-720"></a>        //! \param size Size of name, in characters. This does not include zero terminator, if one is present.
<a name="cl-721"></a>        void name(const Ch *name, std::size_t size)
<a name="cl-722"></a>        {
<a name="cl-723"></a>            m_name = const_cast&lt;Ch *&gt;(name);
<a name="cl-724"></a>            m_name_size = size;
<a name="cl-725"></a>        }
<a name="cl-726"></a>
<a name="cl-727"></a>        //! Sets name of node to a zero-terminated string.
<a name="cl-728"></a>        //! See also \ref ownership_of_strings and xml_node::name(const Ch *, std::size_t).
<a name="cl-729"></a>        //! \param name Name of node to set. Must be zero terminated.
<a name="cl-730"></a>        void name(const Ch *name)
<a name="cl-731"></a>        {
<a name="cl-732"></a>            this-&gt;name(name, internal::measure(name));
<a name="cl-733"></a>        }
<a name="cl-734"></a>
<a name="cl-735"></a>        //! Sets value of node to a non zero-terminated string.
<a name="cl-736"></a>        //! See \ref ownership_of_strings.
<a name="cl-737"></a>        //! &lt;br&gt;&lt;br&gt;
<a name="cl-738"></a>        //! Note that node does not own its name or value, it only stores a pointer to it. 
<a name="cl-739"></a>        //! It will not delete or otherwise free the pointer on destruction.
<a name="cl-740"></a>        //! It is reponsibility of the user to properly manage lifetime of the string.
<a name="cl-741"></a>        //! The easiest way to achieve it is to use memory_pool of the document to allocate the string -
<a name="cl-742"></a>        //! on destruction of the document the string will be automatically freed.
<a name="cl-743"></a>        //! &lt;br&gt;&lt;br&gt;
<a name="cl-744"></a>        //! Size of value must be specified separately, because it does not have to be zero terminated.
<a name="cl-745"></a>        //! Use value(const Ch *) function to have the length automatically calculated (string must be zero terminated).
<a name="cl-746"></a>        //! &lt;br&gt;&lt;br&gt;
<a name="cl-747"></a>        //! If an element has a child node of type node_data, it will take precedence over element value when printing.
<a name="cl-748"></a>        //! If you want to manipulate data of elements using values, use parser flag rapidxml::parse_no_data_nodes to prevent creation of data nodes by the parser.
<a name="cl-749"></a>        //! \param value value of node to set. Does not have to be zero terminated.
<a name="cl-750"></a>        //! \param size Size of value, in characters. This does not include zero terminator, if one is present.
<a name="cl-751"></a>        void value(const Ch *value, std::size_t size)
<a name="cl-752"></a>        {
<a name="cl-753"></a>            m_value = const_cast&lt;Ch *&gt;(value);
<a name="cl-754"></a>            m_value_size = size;
<a name="cl-755"></a>        }
<a name="cl-756"></a>
<a name="cl-757"></a>        //! Sets value of node to a zero-terminated string.
<a name="cl-758"></a>        //! See also \ref ownership_of_strings and xml_node::value(const Ch *, std::size_t).
<a name="cl-759"></a>        //! \param value Vame of node to set. Must be zero terminated.
<a name="cl-760"></a>        void value(const Ch *value)
<a name="cl-761"></a>        {
<a name="cl-762"></a>            this-&gt;value(value, internal::measure(value));
<a name="cl-763"></a>        }
<a name="cl-764"></a>
<a name="cl-765"></a>        ///////////////////////////////////////////////////////////////////////////
<a name="cl-766"></a>        // Related nodes access
<a name="cl-767"></a>    
<a name="cl-768"></a>        //! Gets node parent.
<a name="cl-769"></a>        //! \return Pointer to parent node, or 0 if there is no parent.
<a name="cl-770"></a>        xml_node&lt;Ch&gt; *parent() const
<a name="cl-771"></a>        {
<a name="cl-772"></a>            return m_parent;
<a name="cl-773"></a>        }
<a name="cl-774"></a>
<a name="cl-775"></a>    protected:
<a name="cl-776"></a>
<a name="cl-777"></a>        // Return empty string
<a name="cl-778"></a>        static Ch *nullstr()
<a name="cl-779"></a>        {
<a name="cl-780"></a>            static Ch zero = Ch('\0');
<a name="cl-781"></a>            return &amp;zero;
<a name="cl-782"></a>        }
<a name="cl-783"></a>
<a name="cl-784"></a>        Ch *m_name;                         // Name of node, or 0 if no name
<a name="cl-785"></a>        Ch *m_value;                        // Value of node, or 0 if no value
<a name="cl-786"></a>        std::size_t m_name_size;            // Length of node name, or undefined of no name
<a name="cl-787"></a>        std::size_t m_value_size;           // Length of node value, or undefined if no value
<a name="cl-788"></a>        xml_node&lt;Ch&gt; *m_parent;             // Pointer to parent node, or 0 if none
<a name="cl-789"></a>
<a name="cl-790"></a>    };
<a name="cl-791"></a>
<a name="cl-792"></a>    //! Class representing attribute node of XML document. 
<a name="cl-793"></a>    //! Each attribute has name and value strings, which are available through name() and value() functions (inherited from xml_base).
<a name="cl-794"></a>    //! Note that after parse, both name and value of attribute will point to interior of source text used for parsing. 
<a name="cl-795"></a>    //! Thus, this text must persist in memory for the lifetime of attribute.
<a name="cl-796"></a>    //! \param Ch Character type to use.
<a name="cl-797"></a>    template&lt;class Ch = char&gt;
<a name="cl-798"></a>    class xml_attribute: public xml_base&lt;Ch&gt;
<a name="cl-799"></a>    {
<a name="cl-800"></a>
<a name="cl-801"></a>        friend class xml_node&lt;Ch&gt;;
<a name="cl-802"></a>    
<a name="cl-803"></a>    public:
<a name="cl-804"></a>
<a name="cl-805"></a>        ///////////////////////////////////////////////////////////////////////////
<a name="cl-806"></a>        // Construction &amp; destruction
<a name="cl-807"></a>    
<a name="cl-808"></a>        //! Constructs an empty attribute with the specified type. 
<a name="cl-809"></a>        //! Consider using memory_pool of appropriate xml_document if allocating attributes manually.
<a name="cl-810"></a>        xml_attribute()
<a name="cl-811"></a>        {
<a name="cl-812"></a>        }
<a name="cl-813"></a>
<a name="cl-814"></a>        ///////////////////////////////////////////////////////////////////////////
<a name="cl-815"></a>        // Related nodes access
<a name="cl-816"></a>    
<a name="cl-817"></a>        //! Gets document of which attribute is a child.
<a name="cl-818"></a>        //! \return Pointer to document that contains this attribute, or 0 if there is no parent document.
<a name="cl-819"></a>        xml_document&lt;Ch&gt; *document() const
<a name="cl-820"></a>        {
<a name="cl-821"></a>            if (xml_node&lt;Ch&gt; *node = this-&gt;parent())
<a name="cl-822"></a>            {
<a name="cl-823"></a>                while (node-&gt;parent())
<a name="cl-824"></a>                    node = node-&gt;parent();
<a name="cl-825"></a>                return node-&gt;type() == node_document ? static_cast&lt;xml_document&lt;Ch&gt; *&gt;(node) : 0;
<a name="cl-826"></a>            }
<a name="cl-827"></a>            else
<a name="cl-828"></a>                return 0;
<a name="cl-829"></a>        }
<a name="cl-830"></a>
<a name="cl-831"></a>        //! Gets previous attribute, optionally matching attribute name. 
<a name="cl-832"></a>        //! \param name Name of attribute to find, or 0 to return previous attribute regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
<a name="cl-833"></a>        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
<a name="cl-834"></a>        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
<a name="cl-835"></a>        //! \return Pointer to found attribute, or 0 if not found.
<a name="cl-836"></a>        xml_attribute&lt;Ch&gt; *previous_attribute(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
<a name="cl-837"></a>        {
<a name="cl-838"></a>            if (name)
<a name="cl-839"></a>            {
<a name="cl-840"></a>                if (name_size == 0)
<a name="cl-841"></a>                    name_size = internal::measure(name);
<a name="cl-842"></a>                for (xml_attribute&lt;Ch&gt; *attribute = m_prev_attribute; attribute; attribute = attribute-&gt;m_prev_attribute)
<a name="cl-843"></a>                    if (internal::compare(attribute-&gt;name(), attribute-&gt;name_size(), name, name_size, case_sensitive))
<a name="cl-844"></a>                        return attribute;
<a name="cl-845"></a>                return 0;
<a name="cl-846"></a>            }
<a name="cl-847"></a>            else
<a name="cl-848"></a>                return this-&gt;m_parent ? m_prev_attribute : 0;
<a name="cl-849"></a>        }
<a name="cl-850"></a>
<a name="cl-851"></a>        //! Gets next attribute, optionally matching attribute name. 
<a name="cl-852"></a>        //! \param name Name of attribute to find, or 0 to return next attribute regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
<a name="cl-853"></a>        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
<a name="cl-854"></a>        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
<a name="cl-855"></a>        //! \return Pointer to found attribute, or 0 if not found.
<a name="cl-856"></a>        xml_attribute&lt;Ch&gt; *next_attribute(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
<a name="cl-857"></a>        {
<a name="cl-858"></a>            if (name)
<a name="cl-859"></a>            {
<a name="cl-860"></a>                if (name_size == 0)
<a name="cl-861"></a>                    name_size = internal::measure(name);
<a name="cl-862"></a>                for (xml_attribute&lt;Ch&gt; *attribute = m_next_attribute; attribute; attribute = attribute-&gt;m_next_attribute)
<a name="cl-863"></a>                    if (internal::compare(attribute-&gt;name(), attribute-&gt;name_size(), name, name_size, case_sensitive))
<a name="cl-864"></a>                        return attribute;
<a name="cl-865"></a>                return 0;
<a name="cl-866"></a>            }
<a name="cl-867"></a>            else
<a name="cl-868"></a>                return this-&gt;m_parent ? m_next_attribute : 0;
<a name="cl-869"></a>        }
<a name="cl-870"></a>
<a name="cl-871"></a>    private:
<a name="cl-872"></a>
<a name="cl-873"></a>        xml_attribute&lt;Ch&gt; *m_prev_attribute;        // Pointer to previous sibling of attribute, or 0 if none; only valid if parent is non-zero
<a name="cl-874"></a>        xml_attribute&lt;Ch&gt; *m_next_attribute;        // Pointer to next sibling of attribute, or 0 if none; only valid if parent is non-zero
<a name="cl-875"></a>    
<a name="cl-876"></a>    };
<a name="cl-877"></a>
<a name="cl-878"></a>    ///////////////////////////////////////////////////////////////////////////
<a name="cl-879"></a>    // XML node
<a name="cl-880"></a>
<a name="cl-881"></a>    //! Class representing a node of XML document. 
<a name="cl-882"></a>    //! Each node may have associated name and value strings, which are available through name() and value() functions. 
<a name="cl-883"></a>    //! Interpretation of name and value depends on type of the node.
<a name="cl-884"></a>    //! Type of node can be determined by using type() function.
<a name="cl-885"></a>    //! &lt;br&gt;&lt;br&gt;
<a name="cl-886"></a>    //! Note that after parse, both name and value of node, if any, will point interior of source text used for parsing. 
<a name="cl-887"></a>    //! Thus, this text must persist in the memory for the lifetime of node.
<a name="cl-888"></a>    //! \param Ch Character type to use.
<a name="cl-889"></a>    template&lt;class Ch = char&gt;
<a name="cl-890"></a>    class xml_node: public xml_base&lt;Ch&gt;
<a name="cl-891"></a>    {
<a name="cl-892"></a>
<a name="cl-893"></a>    public:
<a name="cl-894"></a>
<a name="cl-895"></a>        ///////////////////////////////////////////////////////////////////////////
<a name="cl-896"></a>        // Construction &amp; destruction
<a name="cl-897"></a>    
<a name="cl-898"></a>        //! Constructs an empty node with the specified type. 
<a name="cl-899"></a>        //! Consider using memory_pool of appropriate document to allocate nodes manually.
<a name="cl-900"></a>        //! \param type Type of node to construct.
<a name="cl-901"></a>        xml_node(node_type type)
<a name="cl-902"></a>            : m_type(type)
<a name="cl-903"></a>            , m_first_node(0)
<a name="cl-904"></a>            , m_first_attribute(0)
<a name="cl-905"></a>        {
<a name="cl-906"></a>        }
<a name="cl-907"></a>
<a name="cl-908"></a>        ///////////////////////////////////////////////////////////////////////////
<a name="cl-909"></a>        // Node data access
<a name="cl-910"></a>    
<a name="cl-911"></a>        //! Gets type of node.
<a name="cl-912"></a>        //! \return Type of node.
<a name="cl-913"></a>        node_type type() const
<a name="cl-914"></a>        {
<a name="cl-915"></a>            return m_type;
<a name="cl-916"></a>        }
<a name="cl-917"></a>
<a name="cl-918"></a>        ///////////////////////////////////////////////////////////////////////////
<a name="cl-919"></a>        // Related nodes access
<a name="cl-920"></a>    
<a name="cl-921"></a>        //! Gets document of which node is a child.
<a name="cl-922"></a>        //! \return Pointer to document that contains this node, or 0 if there is no parent document.
<a name="cl-923"></a>        xml_document&lt;Ch&gt; *document() const
<a name="cl-924"></a>        {
<a name="cl-925"></a>            xml_node&lt;Ch&gt; *node = const_cast&lt;xml_node&lt;Ch&gt; *&gt;(this);
<a name="cl-926"></a>            while (node-&gt;parent())
<a name="cl-927"></a>                node = node-&gt;parent();
<a name="cl-928"></a>            return node-&gt;type() == node_document ? static_cast&lt;xml_document&lt;Ch&gt; *&gt;(node) : 0;
<a name="cl-929"></a>        }
<a name="cl-930"></a>
<a name="cl-931"></a>        //! Gets first child node, optionally matching node name.
<a name="cl-932"></a>        //! \param name Name of child to find, or 0 to return first child regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
<a name="cl-933"></a>        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
<a name="cl-934"></a>        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
<a name="cl-935"></a>        //! \return Pointer to found child, or 0 if not found.
<a name="cl-936"></a>        xml_node&lt;Ch&gt; *first_node(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
<a name="cl-937"></a>        {
<a name="cl-938"></a>            if (name)
<a name="cl-939"></a>            {
<a name="cl-940"></a>                if (name_size == 0)
<a name="cl-941"></a>                    name_size = internal::measure(name);
<a name="cl-942"></a>                for (xml_node&lt;Ch&gt; *child = m_first_node; child; child = child-&gt;next_sibling())
<a name="cl-943"></a>                    if (internal::compare(child-&gt;name(), child-&gt;name_size(), name, name_size, case_sensitive))
<a name="cl-944"></a>                        return child;
<a name="cl-945"></a>                return 0;
<a name="cl-946"></a>            }
<a name="cl-947"></a>            else
<a name="cl-948"></a>                return m_first_node;
<a name="cl-949"></a>        }
<a name="cl-950"></a>
<a name="cl-951"></a>        //! Gets last child node, optionally matching node name. 
<a name="cl-952"></a>        //! Behaviour is undefined if node has no children.
<a name="cl-953"></a>        //! Use first_node() to test if node has children.
<a name="cl-954"></a>        //! \param name Name of child to find, or 0 to return last child regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
<a name="cl-955"></a>        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
<a name="cl-956"></a>        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
<a name="cl-957"></a>        //! \return Pointer to found child, or 0 if not found.
<a name="cl-958"></a>        xml_node&lt;Ch&gt; *last_node(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
<a name="cl-959"></a>        {
<a name="cl-960"></a>            assert(m_first_node);  // Cannot query for last child if node has no children
<a name="cl-961"></a>            if (name)
<a name="cl-962"></a>            {
<a name="cl-963"></a>                if (name_size == 0)
<a name="cl-964"></a>                    name_size = internal::measure(name);
<a name="cl-965"></a>                for (xml_node&lt;Ch&gt; *child = m_last_node; child; child = child-&gt;previous_sibling())
<a name="cl-966"></a>                    if (internal::compare(child-&gt;name(), child-&gt;name_size(), name, name_size, case_sensitive))
<a name="cl-967"></a>                        return child;
<a name="cl-968"></a>                return 0;
<a name="cl-969"></a>            }
<a name="cl-970"></a>            else
<a name="cl-971"></a>                return m_last_node;
<a name="cl-972"></a>        }
<a name="cl-973"></a>
<a name="cl-974"></a>        //! Gets previous sibling node, optionally matching node name. 
<a name="cl-975"></a>        //! Behaviour is undefined if node has no parent.
<a name="cl-976"></a>        //! Use parent() to test if node has a parent.
<a name="cl-977"></a>        //! \param name Name of sibling to find, or 0 to return previous sibling regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
<a name="cl-978"></a>        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
<a name="cl-979"></a>        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
<a name="cl-980"></a>        //! \return Pointer to found sibling, or 0 if not found.
<a name="cl-981"></a>        xml_node&lt;Ch&gt; *previous_sibling(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
<a name="cl-982"></a>        {
<a name="cl-983"></a>            assert(this-&gt;m_parent);     // Cannot query for siblings if node has no parent
<a name="cl-984"></a>            if (name)
<a name="cl-985"></a>            {
<a name="cl-986"></a>                if (name_size == 0)
<a name="cl-987"></a>                    name_size = internal::measure(name);
<a name="cl-988"></a>                for (xml_node&lt;Ch&gt; *sibling = m_prev_sibling; sibling; sibling = sibling-&gt;m_prev_sibling)
<a name="cl-989"></a>                    if (internal::compare(sibling-&gt;name(), sibling-&gt;name_size(), name, name_size, case_sensitive))
<a name="cl-990"></a>                        return sibling;
<a name="cl-991"></a>                return 0;
<a name="cl-992"></a>            }
<a name="cl-993"></a>            else
<a name="cl-994"></a>                return m_prev_sibling;
<a name="cl-995"></a>        }
<a name="cl-996"></a>
<a name="cl-997"></a>        //! Gets next sibling node, optionally matching node name. 
<a name="cl-998"></a>        //! Behaviour is undefined if node has no parent.
<a name="cl-999"></a>        //! Use parent() to test if node has a parent.
<a name="cl-1000"></a>        //! \param name Name of sibling to find, or 0 to return next sibling regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
<a name="cl-1001"></a>        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
<a name="cl-1002"></a>        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
<a name="cl-1003"></a>        //! \return Pointer to found sibling, or 0 if not found.
<a name="cl-1004"></a>        xml_node&lt;Ch&gt; *next_sibling(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
<a name="cl-1005"></a>        {
<a name="cl-1006"></a>            assert(this-&gt;m_parent);     // Cannot query for siblings if node has no parent
<a name="cl-1007"></a>            if (name)
<a name="cl-1008"></a>            {
<a name="cl-1009"></a>                if (name_size == 0)
<a name="cl-1010"></a>                    name_size = internal::measure(name);
<a name="cl-1011"></a>                for (xml_node&lt;Ch&gt; *sibling = m_next_sibling; sibling; sibling = sibling-&gt;m_next_sibling)
<a name="cl-1012"></a>                    if (internal::compare(sibling-&gt;name(), sibling-&gt;name_size(), name, name_size, case_sensitive))
<a name="cl-1013"></a>                        return sibling;
<a name="cl-1014"></a>                return 0;
<a name="cl-1015"></a>            }
<a name="cl-1016"></a>            else
<a name="cl-1017"></a>                return m_next_sibling;
<a name="cl-1018"></a>        }
<a name="cl-1019"></a>
<a name="cl-1020"></a>        //! Gets first attribute of node, optionally matching attribute name.
<a name="cl-1021"></a>        //! \param name Name of attribute to find, or 0 to return first attribute regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
<a name="cl-1022"></a>        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
<a name="cl-1023"></a>        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
<a name="cl-1024"></a>        //! \return Pointer to found attribute, or 0 if not found.
<a name="cl-1025"></a>        xml_attribute&lt;Ch&gt; *first_attribute(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
<a name="cl-1026"></a>        {
<a name="cl-1027"></a>            if (name)
<a name="cl-1028"></a>            {
<a name="cl-1029"></a>                if (name_size == 0)
<a name="cl-1030"></a>                    name_size = internal::measure(name);
<a name="cl-1031"></a>                for (xml_attribute&lt;Ch&gt; *attribute = m_first_attribute; attribute; attribute = attribute-&gt;m_next_attribute)
<a name="cl-1032"></a>                    if (internal::compare(attribute-&gt;name(), attribute-&gt;name_size(), name, name_size, case_sensitive))
<a name="cl-1033"></a>                        return attribute;
<a name="cl-1034"></a>                return 0;
<a name="cl-1035"></a>            }
<a name="cl-1036"></a>            else
<a name="cl-1037"></a>                return m_first_attribute;
<a name="cl-1038"></a>        }
<a name="cl-1039"></a>
<a name="cl-1040"></a>        //! Gets last attribute of node, optionally matching attribute name.
<a name="cl-1041"></a>        //! \param name Name of attribute to find, or 0 to return last attribute regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
<a name="cl-1042"></a>        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
<a name="cl-1043"></a>        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
<a name="cl-1044"></a>        //! \return Pointer to found attribute, or 0 if not found.
<a name="cl-1045"></a>        xml_attribute&lt;Ch&gt; *last_attribute(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
<a name="cl-1046"></a>        {
<a name="cl-1047"></a>            if (name)
<a name="cl-1048"></a>            {
<a name="cl-1049"></a>                if (name_size == 0)
<a name="cl-1050"></a>                    name_size = internal::measure(name);
<a name="cl-1051"></a>                for (xml_attribute&lt;Ch&gt; *attribute = m_last_attribute; attribute; attribute = attribute-&gt;m_prev_attribute)
<a name="cl-1052"></a>                    if (internal::compare(attribute-&gt;name(), attribute-&gt;name_size(), name, name_size, case_sensitive))
<a name="cl-1053"></a>                        return attribute;
<a name="cl-1054"></a>                return 0;
<a name="cl-1055"></a>            }
<a name="cl-1056"></a>            else
<a name="cl-1057"></a>                return m_first_attribute ? m_last_attribute : 0;
<a name="cl-1058"></a>        }
<a name="cl-1059"></a>
<a name="cl-1060"></a>        ///////////////////////////////////////////////////////////////////////////
<a name="cl-1061"></a>        // Node modification
<a name="cl-1062"></a>    
<a name="cl-1063"></a>        //! Sets type of node.
<a name="cl-1064"></a>        //! \param type Type of node to set.
<a name="cl-1065"></a>        void type(node_type type)
<a name="cl-1066"></a>        {
<a name="cl-1067"></a>            m_type = type;
<a name="cl-1068"></a>        }
<a name="cl-1069"></a>
<a name="cl-1070"></a>        ///////////////////////////////////////////////////////////////////////////
<a name="cl-1071"></a>        // Node manipulation
<a name="cl-1072"></a>
<a name="cl-1073"></a>        //! Prepends a new child node.
<a name="cl-1074"></a>        //! The prepended child becomes the first child, and all existing children are moved one position back.
<a name="cl-1075"></a>        //! \param child Node to prepend.
<a name="cl-1076"></a>        void prepend_node(xml_node&lt;Ch&gt; *child)
<a name="cl-1077"></a>        {
<a name="cl-1078"></a>            assert(child &amp;&amp; !child-&gt;parent() &amp;&amp; child-&gt;type() != node_document);
<a name="cl-1079"></a>            if (first_node())
<a name="cl-1080"></a>            {
<a name="cl-1081"></a>                child-&gt;m_next_sibling = m_first_node;
<a name="cl-1082"></a>                m_first_node-&gt;m_prev_sibling = child;
<a name="cl-1083"></a>            }
<a name="cl-1084"></a>            else
<a name="cl-1085"></a>            {
<a name="cl-1086"></a>                child-&gt;m_next_sibling = 0;
<a name="cl-1087"></a>                m_last_node = child;
<a name="cl-1088"></a>            }
<a name="cl-1089"></a>            m_first_node = child;
<a name="cl-1090"></a>            child-&gt;m_parent = this;
<a name="cl-1091"></a>            child-&gt;m_prev_sibling = 0;
<a name="cl-1092"></a>        }
<a name="cl-1093"></a>
<a name="cl-1094"></a>        //! Appends a new child node. 
<a name="cl-1095"></a>        //! The appended child becomes the last child.
<a name="cl-1096"></a>        //! \param child Node to append.
<a name="cl-1097"></a>        void append_node(xml_node&lt;Ch&gt; *child)
<a name="cl-1098"></a>        {
<a name="cl-1099"></a>            assert(child &amp;&amp; !child-&gt;parent() &amp;&amp; child-&gt;type() != node_document);
<a name="cl-1100"></a>            if (first_node())
<a name="cl-1101"></a>            {
<a name="cl-1102"></a>                child-&gt;m_prev_sibling = m_last_node;
<a name="cl-1103"></a>                m_last_node-&gt;m_next_sibling = child;
<a name="cl-1104"></a>            }
<a name="cl-1105"></a>            else
<a name="cl-1106"></a>            {
<a name="cl-1107"></a>                child-&gt;m_prev_sibling = 0;
<a name="cl-1108"></a>                m_first_node = child;
<a name="cl-1109"></a>            }
<a name="cl-1110"></a>            m_last_node = child;
<a name="cl-1111"></a>            child-&gt;m_parent = this;
<a name="cl-1112"></a>            child-&gt;m_next_sibling = 0;
<a name="cl-1113"></a>        }
<a name="cl-1114"></a>
<a name="cl-1115"></a>        //! Inserts a new child node at specified place inside the node. 
<a name="cl-1116"></a>        //! All children after and including the specified node are moved one position back.
<a name="cl-1117"></a>        //! \param where Place where to insert the child, or 0 to insert at the back.
<a name="cl-1118"></a>        //! \param child Node to insert.
<a name="cl-1119"></a>        void insert_node(xml_node&lt;Ch&gt; *where, xml_node&lt;Ch&gt; *child)
<a name="cl-1120"></a>        {
<a name="cl-1121"></a>            assert(!where || where-&gt;parent() == this);
<a name="cl-1122"></a>            assert(child &amp;&amp; !child-&gt;parent() &amp;&amp; child-&gt;type() != node_document);
<a name="cl-1123"></a>            if (where == m_first_node)
<a name="cl-1124"></a>                prepend_node(child);
<a name="cl-1125"></a>            else if (where == 0)
<a name="cl-1126"></a>                append_node(child);
<a name="cl-1127"></a>            else
<a name="cl-1128"></a>            {
<a name="cl-1129"></a>                child-&gt;m_prev_sibling = where-&gt;m_prev_sibling;
<a name="cl-1130"></a>                child-&gt;m_next_sibling = where;
<a name="cl-1131"></a>                where-&gt;m_prev_sibling-&gt;m_next_sibling = child;
<a name="cl-1132"></a>                where-&gt;m_prev_sibling = child;
<a name="cl-1133"></a>                child-&gt;m_parent = this;
<a name="cl-1134"></a>            }
<a name="cl-1135"></a>        }
<a name="cl-1136"></a>
<a name="cl-1137"></a>        //! Removes first child node. 
<a name="cl-1138"></a>        //! If node has no children, behaviour is undefined.
<a name="cl-1139"></a>        //! Use first_node() to test if node has children.
<a name="cl-1140"></a>        void remove_first_node()
<a name="cl-1141"></a>        {
<a name="cl-1142"></a>            assert(first_node());
<a name="cl-1143"></a>            xml_node&lt;Ch&gt; *child = m_first_node;
<a name="cl-1144"></a>            m_first_node = child-&gt;m_next_sibling;
<a name="cl-1145"></a>            if (child-&gt;m_next_sibling)
<a name="cl-1146"></a>                child-&gt;m_next_sibling-&gt;m_prev_sibling = 0;
<a name="cl-1147"></a>            else
<a name="cl-1148"></a>                m_last_node = 0;
<a name="cl-1149"></a>            child-&gt;m_parent = 0;
<a name="cl-1150"></a>        }
<a name="cl-1151"></a>
<a name="cl-1152"></a>        //! Removes last child of the node. 
<a name="cl-1153"></a>        //! If node has no children, behaviour is undefined.
<a name="cl-1154"></a>        //! Use first_node() to test if node has children.
<a name="cl-1155"></a>        void remove_last_node()
<a name="cl-1156"></a>        {
<a name="cl-1157"></a>            assert(first_node());
<a name="cl-1158"></a>            xml_node&lt;Ch&gt; *child = m_last_node;
<a name="cl-1159"></a>            if (child-&gt;m_prev_sibling)
<a name="cl-1160"></a>            {
<a name="cl-1161"></a>                m_last_node = child-&gt;m_prev_sibling;
<a name="cl-1162"></a>                child-&gt;m_prev_sibling-&gt;m_next_sibling = 0;
<a name="cl-1163"></a>            }
<a name="cl-1164"></a>            else
<a name="cl-1165"></a>                m_first_node = 0;
<a name="cl-1166"></a>            child-&gt;m_parent = 0;
<a name="cl-1167"></a>        }
<a name="cl-1168"></a>
<a name="cl-1169"></a>        //! Removes specified child from the node
<a name="cl-1170"></a>        // \param where Pointer to child to be removed.
<a name="cl-1171"></a>        void remove_node(xml_node&lt;Ch&gt; *where)
<a name="cl-1172"></a>        {
<a name="cl-1173"></a>            assert(where &amp;&amp; where-&gt;parent() == this);
<a name="cl-1174"></a>            assert(first_node());
<a name="cl-1175"></a>            if (where == m_first_node)
<a name="cl-1176"></a>                remove_first_node();
<a name="cl-1177"></a>            else if (where == m_last_node)
<a name="cl-1178"></a>                remove_last_node();
<a name="cl-1179"></a>            else
<a name="cl-1180"></a>            {
<a name="cl-1181"></a>                where-&gt;m_prev_sibling-&gt;m_next_sibling = where-&gt;m_next_sibling;
<a name="cl-1182"></a>                where-&gt;m_next_sibling-&gt;m_prev_sibling = where-&gt;m_prev_sibling;
<a name="cl-1183"></a>                where-&gt;m_parent = 0;
<a name="cl-1184"></a>            }
<a name="cl-1185"></a>        }
<a name="cl-1186"></a>
<a name="cl-1187"></a>        //! Removes all child nodes (but not attributes).
<a name="cl-1188"></a>        void remove_all_nodes()
<a name="cl-1189"></a>        {
<a name="cl-1190"></a>            for (xml_node&lt;Ch&gt; *node = first_node(); node; node = node-&gt;m_next_sibling)
<a name="cl-1191"></a>                node-&gt;m_parent = 0;
<a name="cl-1192"></a>            m_first_node = 0;
<a name="cl-1193"></a>        }
<a name="cl-1194"></a>
<a name="cl-1195"></a>        //! Prepends a new attribute to the node.
<a name="cl-1196"></a>        //! \param attribute Attribute to prepend.
<a name="cl-1197"></a>        void prepend_attribute(xml_attribute&lt;Ch&gt; *attribute)
<a name="cl-1198"></a>        {
<a name="cl-1199"></a>            assert(attribute &amp;&amp; !attribute-&gt;parent());
<a name="cl-1200"></a>            if (first_attribute())
<a name="cl-1201"></a>            {
<a name="cl-1202"></a>                attribute-&gt;m_next_attribute = m_first_attribute;
<a name="cl-1203"></a>                m_first_attribute-&gt;m_prev_attribute = attribute;
<a name="cl-1204"></a>            }
<a name="cl-1205"></a>            else
<a name="cl-1206"></a>            {
<a name="cl-1207"></a>                attribute-&gt;m_next_attribute = 0;
<a name="cl-1208"></a>                m_last_attribute = attribute;
<a name="cl-1209"></a>            }
<a name="cl-1210"></a>            m_first_attribute = attribute;
<a name="cl-1211"></a>            attribute-&gt;m_parent = this;
<a name="cl-1212"></a>            attribute-&gt;m_prev_attribute = 0;
<a name="cl-1213"></a>        }
<a name="cl-1214"></a>
<a name="cl-1215"></a>        //! Appends a new attribute to the node.
<a name="cl-1216"></a>        //! \param attribute Attribute to append.
<a name="cl-1217"></a>        void append_attribute(xml_attribute&lt;Ch&gt; *attribute)
<a name="cl-1218"></a>        {
<a name="cl-1219"></a>            assert(attribute &amp;&amp; !attribute-&gt;parent());
<a name="cl-1220"></a>            if (first_attribute())
<a name="cl-1221"></a>            {
<a name="cl-1222"></a>                attribute-&gt;m_prev_attribute = m_last_attribute;
<a name="cl-1223"></a>                m_last_attribute-&gt;m_next_attribute = attribute;
<a name="cl-1224"></a>            }
<a name="cl-1225"></a>            else
<a name="cl-1226"></a>            {
<a name="cl-1227"></a>                attribute-&gt;m_prev_attribute = 0;
<a name="cl-1228"></a>                m_first_attribute = attribute;
<a name="cl-1229"></a>            }
<a name="cl-1230"></a>            m_last_attribute = attribute;
<a name="cl-1231"></a>            attribute-&gt;m_parent = this;
<a name="cl-1232"></a>            attribute-&gt;m_next_attribute = 0;
<a name="cl-1233"></a>        }
<a name="cl-1234"></a>
<a name="cl-1235"></a>        //! Inserts a new attribute at specified place inside the node. 
<a name="cl-1236"></a>        //! All attributes after and including the specified attribute are moved one position back.
<a name="cl-1237"></a>        //! \param where Place where to insert the attribute, or 0 to insert at the back.
<a name="cl-1238"></a>        //! \param attribute Attribute to insert.
<a name="cl-1239"></a>        void insert_attribute(xml_attribute&lt;Ch&gt; *where, xml_attribute&lt;Ch&gt; *attribute)
<a name="cl-1240"></a>        {
<a name="cl-1241"></a>            assert(!where || where-&gt;parent() == this);
<a name="cl-1242"></a>            assert(attribute &amp;&amp; !attribute-&gt;parent());
<a name="cl-1243"></a>            if (where == m_first_attribute)
<a name="cl-1244"></a>                prepend_attribute(attribute);
<a name="cl-1245"></a>            else if (where == 0)
<a name="cl-1246"></a>                append_attribute(attribute);
<a name="cl-1247"></a>            else
<a name="cl-1248"></a>            {
<a name="cl-1249"></a>                attribute-&gt;m_prev_attribute = where-&gt;m_prev_attribute;
<a name="cl-1250"></a>                attribute-&gt;m_next_attribute = where;
<a name="cl-1251"></a>                where-&gt;m_prev_attribute-&gt;m_next_attribute = attribute;
<a name="cl-1252"></a>                where-&gt;m_prev_attribute = attribute;
<a name="cl-1253"></a>                attribute-&gt;m_parent = this;
<a name="cl-1254"></a>            }
<a name="cl-1255"></a>        }
<a name="cl-1256"></a>
<a name="cl-1257"></a>        //! Removes first attribute of the node. 
<a name="cl-1258"></a>        //! If node has no attributes, behaviour is undefined.
<a name="cl-1259"></a>        //! Use first_attribute() to test if node has attributes.
<a name="cl-1260"></a>        void remove_first_attribute()
<a name="cl-1261"></a>        {
<a name="cl-1262"></a>            assert(first_attribute());
<a name="cl-1263"></a>            xml_attribute&lt;Ch&gt; *attribute = m_first_attribute;
<a name="cl-1264"></a>            if (attribute-&gt;m_next_attribute)
<a name="cl-1265"></a>            {
<a name="cl-1266"></a>                attribute-&gt;m_next_attribute-&gt;m_prev_attribute = 0;
<a name="cl-1267"></a>            }
<a name="cl-1268"></a>            else
<a name="cl-1269"></a>                m_last_attribute = 0;
<a name="cl-1270"></a>            attribute-&gt;m_parent = 0;
<a name="cl-1271"></a>            m_first_attribute = attribute-&gt;m_next_attribute;
<a name="cl-1272"></a>        }
<a name="cl-1273"></a>
<a name="cl-1274"></a>        //! Removes last attribute of the node. 
<a name="cl-1275"></a>        //! If node has no attributes, behaviour is undefined.
<a name="cl-1276"></a>        //! Use first_attribute() to test if node has attributes.
<a name="cl-1277"></a>        void remove_last_attribute()
<a name="cl-1278"></a>        {
<a name="cl-1279"></a>            assert(first_attribute());
<a name="cl-1280"></a>            xml_attribute&lt;Ch&gt; *attribute = m_last_attribute;
<a name="cl-1281"></a>            if (attribute-&gt;m_prev_attribute)
<a name="cl-1282"></a>            {
<a name="cl-1283"></a>                attribute-&gt;m_prev_attribute-&gt;m_next_attribute = 0;
<a name="cl-1284"></a>                m_last_attribute = attribute-&gt;m_prev_attribute;
<a name="cl-1285"></a>            }
<a name="cl-1286"></a>            else
<a name="cl-1287"></a>                m_first_attribute = 0;
<a name="cl-1288"></a>            attribute-&gt;m_parent = 0;
<a name="cl-1289"></a>        }
<a name="cl-1290"></a>
<a name="cl-1291"></a>        //! Removes specified attribute from node.
<a name="cl-1292"></a>        //! \param where Pointer to attribute to be removed.
<a name="cl-1293"></a>        void remove_attribute(xml_attribute&lt;Ch&gt; *where)
<a name="cl-1294"></a>        {
<a name="cl-1295"></a>            assert(first_attribute() &amp;&amp; where-&gt;parent() == this);
<a name="cl-1296"></a>            if (where == m_first_attribute)
<a name="cl-1297"></a>                remove_first_attribute();
<a name="cl-1298"></a>            else if (where == m_last_attribute)
<a name="cl-1299"></a>                remove_last_attribute();
<a name="cl-1300"></a>            else
<a name="cl-1301"></a>            {
<a name="cl-1302"></a>                where-&gt;m_prev_attribute-&gt;m_next_attribute = where-&gt;m_next_attribute;
<a name="cl-1303"></a>                where-&gt;m_next_attribute-&gt;m_prev_attribute = where-&gt;m_prev_attribute;
<a name="cl-1304"></a>                where-&gt;m_parent = 0;
<a name="cl-1305"></a>            }
<a name="cl-1306"></a>        }
<a name="cl-1307"></a>
<a name="cl-1308"></a>        //! Removes all attributes of node.
<a name="cl-1309"></a>        void remove_all_attributes()
<a name="cl-1310"></a>        {
<a name="cl-1311"></a>            for (xml_attribute&lt;Ch&gt; *attribute = first_attribute(); attribute; attribute = attribute-&gt;m_next_attribute)
<a name="cl-1312"></a>                attribute-&gt;m_parent = 0;
<a name="cl-1313"></a>            m_first_attribute = 0;
<a name="cl-1314"></a>        }
<a name="cl-1315"></a>        
<a name="cl-1316"></a>    private:
<a name="cl-1317"></a>
<a name="cl-1318"></a>        ///////////////////////////////////////////////////////////////////////////
<a name="cl-1319"></a>        // Restrictions
<a name="cl-1320"></a>
<a name="cl-1321"></a>        // No copying
<a name="cl-1322"></a>        xml_node(const xml_node &amp;);
<a name="cl-1323"></a>        void operator =(const xml_node &amp;);
<a name="cl-1324"></a>    
<a name="cl-1325"></a>        ///////////////////////////////////////////////////////////////////////////
<a name="cl-1326"></a>        // Data members
<a name="cl-1327"></a>    
<a name="cl-1328"></a>        // Note that some of the pointers below have UNDEFINED values if certain other pointers are 0.
<a name="cl-1329"></a>        // This is required for maximum performance, as it allows the parser to omit initialization of 
<a name="cl-1330"></a>        // unneded/redundant values.
<a name="cl-1331"></a>        //
<a name="cl-1332"></a>        // The rules are as follows:
<a name="cl-1333"></a>        // 1. first_node and first_attribute contain valid pointers, or 0 if node has no children/attributes respectively
<a name="cl-1334"></a>        // 2. last_node and last_attribute are valid only if node has at least one child/attribute respectively, otherwise they contain garbage
<a name="cl-1335"></a>        // 3. prev_sibling and next_sibling are valid only if node has a parent, otherwise they contain garbage
<a name="cl-1336"></a>
<a name="cl-1337"></a>        node_type m_type;                       // Type of node; always valid
<a name="cl-1338"></a>        xml_node&lt;Ch&gt; *m_first_node;             // Pointer to first child node, or 0 if none; always valid
<a name="cl-1339"></a>        xml_node&lt;Ch&gt; *m_last_node;              // Pointer to last child node, or 0 if none; this value is only valid if m_first_node is non-zero
<a name="cl-1340"></a>        xml_attribute&lt;Ch&gt; *m_first_attribute;   // Pointer to first attribute of node, or 0 if none; always valid
<a name="cl-1341"></a>        xml_attribute&lt;Ch&gt; *m_last_attribute;    // Pointer to last attribute of node, or 0 if none; this value is only valid if m_first_attribute is non-zero
<a name="cl-1342"></a>        xml_node&lt;Ch&gt; *m_prev_sibling;           // Pointer to previous sibling of node, or 0 if none; this value is only valid if m_parent is non-zero
<a name="cl-1343"></a>        xml_node&lt;Ch&gt; *m_next_sibling;           // Pointer to next sibling of node, or 0 if none; this value is only valid if m_parent is non-zero
<a name="cl-1344"></a>
<a name="cl-1345"></a>    };
<a name="cl-1346"></a>
<a name="cl-1347"></a>    ///////////////////////////////////////////////////////////////////////////
<a name="cl-1348"></a>    // XML document
<a name="cl-1349"></a>    
<a name="cl-1350"></a>    //! This class represents root of the DOM hierarchy. 
<a name="cl-1351"></a>    //! It is also an xml_node and a memory_pool through public inheritance.
<a name="cl-1352"></a>    //! Use parse() function to build a DOM tree from a zero-terminated XML text string.
<a name="cl-1353"></a>    //! parse() function allocates memory for nodes and attributes by using functions of xml_document, 
<a name="cl-1354"></a>    //! which are inherited from memory_pool.
<a name="cl-1355"></a>    //! To access root node of the document, use the document itself, as if it was an xml_node.
<a name="cl-1356"></a>    //! \param Ch Character type to use.
<a name="cl-1357"></a>    template&lt;class Ch = char&gt;
<a name="cl-1358"></a>    class xml_document: public xml_node&lt;Ch&gt;, public memory_pool&lt;Ch&gt;
<a name="cl-1359"></a>    {
<a name="cl-1360"></a>    
<a name="cl-1361"></a>    public:
<a name="cl-1362"></a>
<a name="cl-1363"></a>        //! Constructs empty XML document
<a name="cl-1364"></a>        xml_document()
<a name="cl-1365"></a>            : xml_node&lt;Ch&gt;(node_document)
<a name="cl-1366"></a>        {
<a name="cl-1367"></a>        }
<a name="cl-1368"></a>
<a name="cl-1369"></a>        //! Parses zero-terminated XML string according to given flags.
<a name="cl-1370"></a>        //! Passed string will be modified by the parser, unless rapidxml::parse_non_destructive flag is used.
<a name="cl-1371"></a>        //! The string must persist for the lifetime of the document.
<a name="cl-1372"></a>        //! In case of error, rapidxml::parse_error exception will be thrown.
<a name="cl-1373"></a>        //! &lt;br&gt;&lt;br&gt;
<a name="cl-1374"></a>        //! If you want to parse contents of a file, you must first load the file into the memory, and pass pointer to its beginning.
<a name="cl-1375"></a>        //! Make sure that data is zero-terminated.
<a name="cl-1376"></a>        //! &lt;br&gt;&lt;br&gt;
<a name="cl-1377"></a>        //! Document can be parsed into multiple times. 
<a name="cl-1378"></a>        //! Each new call to parse removes previous nodes and attributes (if any), but does not clear memory pool.
<a name="cl-1379"></a>        //! \param text XML data to parse; pointer is non-const to denote fact that this data may be modified by the parser.
<a name="cl-1380"></a>        template&lt;int Flags&gt;
<a name="cl-1381"></a>        void parse(Ch *text)
<a name="cl-1382"></a>        {
<a name="cl-1383"></a>            assert(text);
<a name="cl-1384"></a>            
<a name="cl-1385"></a>            // Remove current contents
<a name="cl-1386"></a>            this-&gt;remove_all_nodes();
<a name="cl-1387"></a>            this-&gt;remove_all_attributes();
<a name="cl-1388"></a>            
<a name="cl-1389"></a>            // Parse BOM, if any
<a name="cl-1390"></a>            parse_bom&lt;Flags&gt;(text);
<a name="cl-1391"></a>            
<a name="cl-1392"></a>            // Parse children
<a name="cl-1393"></a>            while (1)
<a name="cl-1394"></a>            {
<a name="cl-1395"></a>                // Skip whitespace before node
<a name="cl-1396"></a>                skip&lt;whitespace_pred, Flags&gt;(text);
<a name="cl-1397"></a>                if (*text == 0)
<a name="cl-1398"></a>                    break;
<a name="cl-1399"></a>
<a name="cl-1400"></a>                // Parse and append new child
<a name="cl-1401"></a>                if (*text == Ch('&lt;'))
<a name="cl-1402"></a>                {
<a name="cl-1403"></a>                    ++text;     // Skip '&lt;'
<a name="cl-1404"></a>                    if (xml_node&lt;Ch&gt; *node = parse_node&lt;Flags&gt;(text))
<a name="cl-1405"></a>                        this-&gt;append_node(node);
<a name="cl-1406"></a>                }
<a name="cl-1407"></a>                else
<a name="cl-1408"></a>                    RAPIDXML_PARSE_ERROR("expected &lt;", text);
<a name="cl-1409"></a>            }
<a name="cl-1410"></a>
<a name="cl-1411"></a>        }
<a name="cl-1412"></a>
<a name="cl-1413"></a>        //! Clears the document by deleting all nodes and clearing the memory pool.
<a name="cl-1414"></a>        //! All nodes owned by document pool are destroyed.
<a name="cl-1415"></a>        void clear()
<a name="cl-1416"></a>        {
<a name="cl-1417"></a>            this-&gt;remove_all_nodes();
<a name="cl-1418"></a>            this-&gt;remove_all_attributes();
<a name="cl-1419"></a>            memory_pool&lt;Ch&gt;::clear();
<a name="cl-1420"></a>        }
<a name="cl-1421"></a>        
<a name="cl-1422"></a>    private:
<a name="cl-1423"></a>
<a name="cl-1424"></a>        ///////////////////////////////////////////////////////////////////////
<a name="cl-1425"></a>        // Internal character utility functions
<a name="cl-1426"></a>        
<a name="cl-1427"></a>        // Detect whitespace character
<a name="cl-1428"></a>        struct whitespace_pred
<a name="cl-1429"></a>        {
<a name="cl-1430"></a>            static unsigned char test(Ch ch)
<a name="cl-1431"></a>            {
<a name="cl-1432"></a>                return internal::lookup_tables&lt;0&gt;::lookup_whitespace[static_cast&lt;unsigned char&gt;(ch)];
<a name="cl-1433"></a>            }
<a name="cl-1434"></a>        };
<a name="cl-1435"></a>
<a name="cl-1436"></a>        // Detect node name character
<a name="cl-1437"></a>        struct node_name_pred
<a name="cl-1438"></a>        {
<a name="cl-1439"></a>            static unsigned char test(Ch ch)
<a name="cl-1440"></a>            {
<a name="cl-1441"></a>                return internal::lookup_tables&lt;0&gt;::lookup_node_name[static_cast&lt;unsigned char&gt;(ch)];
<a name="cl-1442"></a>            }
<a name="cl-1443"></a>        };
<a name="cl-1444"></a>
<a name="cl-1445"></a>        // Detect attribute name character
<a name="cl-1446"></a>        struct attribute_name_pred
<a name="cl-1447"></a>        {
<a name="cl-1448"></a>            static unsigned char test(Ch ch)
<a name="cl-1449"></a>            {
<a name="cl-1450"></a>                return internal::lookup_tables&lt;0&gt;::lookup_attribute_name[static_cast&lt;unsigned char&gt;(ch)];
<a name="cl-1451"></a>            }
<a name="cl-1452"></a>        };
<a name="cl-1453"></a>
<a name="cl-1454"></a>        // Detect text character (PCDATA)
<a name="cl-1455"></a>        struct text_pred
<a name="cl-1456"></a>        {
<a name="cl-1457"></a>            static unsigned char test(Ch ch)
<a name="cl-1458"></a>            {
<a name="cl-1459"></a>                return internal::lookup_tables&lt;0&gt;::lookup_text[static_cast&lt;unsigned char&gt;(ch)];
<a name="cl-1460"></a>            }
<a name="cl-1461"></a>        };
<a name="cl-1462"></a>
<a name="cl-1463"></a>        // Detect text character (PCDATA) that does not require processing
<a name="cl-1464"></a>        struct text_pure_no_ws_pred
<a name="cl-1465"></a>        {
<a name="cl-1466"></a>            static unsigned char test(Ch ch)
<a name="cl-1467"></a>            {
<a name="cl-1468"></a>                return internal::lookup_tables&lt;0&gt;::lookup_text_pure_no_ws[static_cast&lt;unsigned char&gt;(ch)];
<a name="cl-1469"></a>            }
<a name="cl-1470"></a>        };
<a name="cl-1471"></a>
<a name="cl-1472"></a>        // Detect text character (PCDATA) that does not require processing
<a name="cl-1473"></a>        struct text_pure_with_ws_pred
<a name="cl-1474"></a>        {
<a name="cl-1475"></a>            static unsigned char test(Ch ch)
<a name="cl-1476"></a>            {
<a name="cl-1477"></a>                return internal::lookup_tables&lt;0&gt;::lookup_text_pure_with_ws[static_cast&lt;unsigned char&gt;(ch)];
<a name="cl-1478"></a>            }
<a name="cl-1479"></a>        };
<a name="cl-1480"></a>
<a name="cl-1481"></a>        // Detect attribute value character
<a name="cl-1482"></a>        template&lt;Ch Quote&gt;
<a name="cl-1483"></a>        struct attribute_value_pred
<a name="cl-1484"></a>        {
<a name="cl-1485"></a>            static unsigned char test(Ch ch)
<a name="cl-1486"></a>            {
<a name="cl-1487"></a>                if (Quote == Ch('\''))
<a name="cl-1488"></a>                    return internal::lookup_tables&lt;0&gt;::lookup_attribute_data_1[static_cast&lt;unsigned char&gt;(ch)];
<a name="cl-1489"></a>                if (Quote == Ch('\"'))
<a name="cl-1490"></a>                    return internal::lookup_tables&lt;0&gt;::lookup_attribute_data_2[static_cast&lt;unsigned char&gt;(ch)];
<a name="cl-1491"></a>                return 0;       // Should never be executed, to avoid warnings on Comeau
<a name="cl-1492"></a>            }
<a name="cl-1493"></a>        };
<a name="cl-1494"></a>
<a name="cl-1495"></a>        // Detect attribute value character
<a name="cl-1496"></a>        template&lt;Ch Quote&gt;
<a name="cl-1497"></a>        struct attribute_value_pure_pred
<a name="cl-1498"></a>        {
<a name="cl-1499"></a>            static unsigned char test(Ch ch)
<a name="cl-1500"></a>            {
<a name="cl-1501"></a>                if (Quote == Ch('\''))
<a name="cl-1502"></a>                    return internal::lookup_tables&lt;0&gt;::lookup_attribute_data_1_pure[static_cast&lt;unsigned char&gt;(ch)];
<a name="cl-1503"></a>                if (Quote == Ch('\"'))
<a name="cl-1504"></a>                    return internal::lookup_tables&lt;0&gt;::lookup_attribute_data_2_pure[static_cast&lt;unsigned char&gt;(ch)];
<a name="cl-1505"></a>                return 0;       // Should never be executed, to avoid warnings on Comeau
<a name="cl-1506"></a>            }
<a name="cl-1507"></a>        };
<a name="cl-1508"></a>
<a name="cl-1509"></a>        // Insert coded character, using UTF8 or 8-bit ASCII
<a name="cl-1510"></a>        template&lt;int Flags&gt;
<a name="cl-1511"></a>        static void insert_coded_character(Ch *&amp;text, unsigned long code)
<a name="cl-1512"></a>        {
<a name="cl-1513"></a>            if (Flags &amp; parse_no_utf8)
<a name="cl-1514"></a>            {
<a name="cl-1515"></a>                // Insert 8-bit ASCII character
<a name="cl-1516"></a>                // Todo: possibly verify that code is less than 256 and use replacement char otherwise?
<a name="cl-1517"></a>                text[0] = static_cast&lt;unsigned char&gt;(code);
<a name="cl-1518"></a>                text += 1;
<a name="cl-1519"></a>            }
<a name="cl-1520"></a>            else
<a name="cl-1521"></a>            {
<a name="cl-1522"></a>                // Insert UTF8 sequence
<a name="cl-1523"></a>                if (code &lt; 0x80)    // 1 byte sequence
<a name="cl-1524"></a>                {
<a name="cl-1525"></a>	                text[0] = static_cast&lt;unsigned char&gt;(code);
<a name="cl-1526"></a>                    text += 1;
<a name="cl-1527"></a>                }
<a name="cl-1528"></a>                else if (code &lt; 0x800)  // 2 byte sequence
<a name="cl-1529"></a>                {
<a name="cl-1530"></a>	                text[1] = static_cast&lt;unsigned char&gt;((code | 0x80) &amp; 0xBF); code &gt;&gt;= 6;
<a name="cl-1531"></a>	                text[0] = static_cast&lt;unsigned char&gt;(code | 0xC0);
<a name="cl-1532"></a>                    text += 2;
<a name="cl-1533"></a>                }
<a name="cl-1534"></a>	            else if (code &lt; 0x10000)    // 3 byte sequence
<a name="cl-1535"></a>                {
<a name="cl-1536"></a>	                text[2] = static_cast&lt;unsigned char&gt;((code | 0x80) &amp; 0xBF); code &gt;&gt;= 6;
<a name="cl-1537"></a>	                text[1] = static_cast&lt;unsigned char&gt;((code | 0x80) &amp; 0xBF); code &gt;&gt;= 6;
<a name="cl-1538"></a>	                text[0] = static_cast&lt;unsigned char&gt;(code | 0xE0);
<a name="cl-1539"></a>                    text += 3;
<a name="cl-1540"></a>                }
<a name="cl-1541"></a>	            else if (code &lt; 0x110000)   // 4 byte sequence
<a name="cl-1542"></a>                {
<a name="cl-1543"></a>	                text[3] = static_cast&lt;unsigned char&gt;((code | 0x80) &amp; 0xBF); code &gt;&gt;= 6;
<a name="cl-1544"></a>	                text[2] = static_cast&lt;unsigned char&gt;((code | 0x80) &amp; 0xBF); code &gt;&gt;= 6;
<a name="cl-1545"></a>	                text[1] = static_cast&lt;unsigned char&gt;((code | 0x80) &amp; 0xBF); code &gt;&gt;= 6;
<a name="cl-1546"></a>	                text[0] = static_cast&lt;unsigned char&gt;(code | 0xF0);
<a name="cl-1547"></a>                    text += 4;
<a name="cl-1548"></a>                }
<a name="cl-1549"></a>                else    // Invalid, only codes up to 0x10FFFF are allowed in Unicode
<a name="cl-1550"></a>                {
<a name="cl-1551"></a>                    RAPIDXML_PARSE_ERROR("invalid numeric character entity", text);
<a name="cl-1552"></a>                }
<a name="cl-1553"></a>            }
<a name="cl-1554"></a>        }
<a name="cl-1555"></a>
<a name="cl-1556"></a>        // Skip characters until predicate evaluates to true
<a name="cl-1557"></a>        template&lt;class StopPred, int Flags&gt;
<a name="cl-1558"></a>        static void skip(Ch *&amp;text)
<a name="cl-1559"></a>        {
<a name="cl-1560"></a>            Ch *tmp = text;
<a name="cl-1561"></a>            while (StopPred::test(*tmp))
<a name="cl-1562"></a>                ++tmp;
<a name="cl-1563"></a>            text = tmp;
<a name="cl-1564"></a>        }
<a name="cl-1565"></a>
<a name="cl-1566"></a>        // Skip characters until predicate evaluates to true while doing the following:
<a name="cl-1567"></a>        // - replacing XML character entity references with proper characters (&amp;apos; &amp;amp; &amp;quot; &amp;lt; &amp;gt; &amp;#...;)
<a name="cl-1568"></a>        // - condensing whitespace sequences to single space character
<a name="cl-1569"></a>        template&lt;class StopPred, class StopPredPure, int Flags&gt;
<a name="cl-1570"></a>        static Ch *skip_and_expand_character_refs(Ch *&amp;text)
<a name="cl-1571"></a>        {
<a name="cl-1572"></a>            // If entity translation, whitespace condense and whitespace trimming is disabled, use plain skip
<a name="cl-1573"></a>            if (Flags &amp; parse_no_entity_translation &amp;&amp; 
<a name="cl-1574"></a>                !(Flags &amp; parse_normalize_whitespace) &amp;&amp;
<a name="cl-1575"></a>                !(Flags &amp; parse_trim_whitespace))
<a name="cl-1576"></a>            {
<a name="cl-1577"></a>                skip&lt;StopPred, Flags&gt;(text);
<a name="cl-1578"></a>                return text;
<a name="cl-1579"></a>            }
<a name="cl-1580"></a>            
<a name="cl-1581"></a>            // Use simple skip until first modification is detected
<a name="cl-1582"></a>            skip&lt;StopPredPure, Flags&gt;(text);
<a name="cl-1583"></a>
<a name="cl-1584"></a>            // Use translation skip
<a name="cl-1585"></a>            Ch *src = text;
<a name="cl-1586"></a>            Ch *dest = src;
<a name="cl-1587"></a>            while (StopPred::test(*src))
<a name="cl-1588"></a>            {
<a name="cl-1589"></a>                // If entity translation is enabled    
<a name="cl-1590"></a>                if (!(Flags &amp; parse_no_entity_translation))
<a name="cl-1591"></a>                {
<a name="cl-1592"></a>                    // Test if replacement is needed
<a name="cl-1593"></a>                    if (src[0] == Ch('&amp;'))
<a name="cl-1594"></a>                    {
<a name="cl-1595"></a>                        switch (src[1])
<a name="cl-1596"></a>                        {
<a name="cl-1597"></a>
<a name="cl-1598"></a>                        // &amp;amp; &amp;apos;
<a name="cl-1599"></a>                        case Ch('a'): 
<a name="cl-1600"></a>                            if (src[2] == Ch('m') &amp;&amp; src[3] == Ch('p') &amp;&amp; src[4] == Ch(';'))
<a name="cl-1601"></a>                            {
<a name="cl-1602"></a>                                *dest = Ch('&amp;');
<a name="cl-1603"></a>                                ++dest;
<a name="cl-1604"></a>                                src += 5;
<a name="cl-1605"></a>                                continue;
<a name="cl-1606"></a>                            }
<a name="cl-1607"></a>                            if (src[2] == Ch('p') &amp;&amp; src[3] == Ch('o') &amp;&amp; src[4] == Ch('s') &amp;&amp; src[5] == Ch(';'))
<a name="cl-1608"></a>                            {
<a name="cl-1609"></a>                                *dest = Ch('\'');
<a name="cl-1610"></a>                                ++dest;
<a name="cl-1611"></a>                                src += 6;
<a name="cl-1612"></a>                                continue;
<a name="cl-1613"></a>                            }
<a name="cl-1614"></a>                            break;
<a name="cl-1615"></a>
<a name="cl-1616"></a>                        // &amp;quot;
<a name="cl-1617"></a>                        case Ch('q'): 
<a name="cl-1618"></a>                            if (src[2] == Ch('u') &amp;&amp; src[3] == Ch('o') &amp;&amp; src[4] == Ch('t') &amp;&amp; src[5] == Ch(';'))
<a name="cl-1619"></a>                            {
<a name="cl-1620"></a>                                *dest = Ch('"');
<a name="cl-1621"></a>                                ++dest;
<a name="cl-1622"></a>                                src += 6;
<a name="cl-1623"></a>                                continue;
<a name="cl-1624"></a>                            }
<a name="cl-1625"></a>                            break;
<a name="cl-1626"></a>
<a name="cl-1627"></a>                        // &amp;gt;
<a name="cl-1628"></a>                        case Ch('g'): 
<a name="cl-1629"></a>                            if (src[2] == Ch('t') &amp;&amp; src[3] == Ch(';'))
<a name="cl-1630"></a>                            {
<a name="cl-1631"></a>                                *dest = Ch('&gt;');
<a name="cl-1632"></a>                                ++dest;
<a name="cl-1633"></a>                                src += 4;
<a name="cl-1634"></a>                                continue;
<a name="cl-1635"></a>                            }
<a name="cl-1636"></a>                            break;
<a name="cl-1637"></a>
<a name="cl-1638"></a>                        // &amp;lt;
<a name="cl-1639"></a>                        case Ch('l'): 
<a name="cl-1640"></a>                            if (src[2] == Ch('t') &amp;&amp; src[3] == Ch(';'))
<a name="cl-1641"></a>                            {
<a name="cl-1642"></a>                                *dest = Ch('&lt;');
<a name="cl-1643"></a>                                ++dest;
<a name="cl-1644"></a>                                src += 4;
<a name="cl-1645"></a>                                continue;
<a name="cl-1646"></a>                            }
<a name="cl-1647"></a>                            break;
<a name="cl-1648"></a>
<a name="cl-1649"></a>                        // &amp;#...; - assumes ASCII
<a name="cl-1650"></a>                        case Ch('#'): 
<a name="cl-1651"></a>                            if (src[2] == Ch('x'))
<a name="cl-1652"></a>                            {
<a name="cl-1653"></a>                                unsigned long code = 0;
<a name="cl-1654"></a>                                src += 3;   // Skip &amp;#x
<a name="cl-1655"></a>                                while (1)
<a name="cl-1656"></a>                                {
<a name="cl-1657"></a>                                    unsigned char digit = internal::lookup_tables&lt;0&gt;::lookup_digits[static_cast&lt;unsigned char&gt;(*src)];
<a name="cl-1658"></a>                                    if (digit == 0xFF)
<a name="cl-1659"></a>                                        break;
<a name="cl-1660"></a>                                    code = code * 16 + digit;
<a name="cl-1661"></a>                                    ++src;
<a name="cl-1662"></a>                                }
<a name="cl-1663"></a>                                insert_coded_character&lt;Flags&gt;(dest, code);    // Put character in output
<a name="cl-1664"></a>                            }
<a name="cl-1665"></a>                            else
<a name="cl-1666"></a>                            {
<a name="cl-1667"></a>                                unsigned long code = 0;
<a name="cl-1668"></a>                                src += 2;   // Skip &amp;#
<a name="cl-1669"></a>                                while (1)
<a name="cl-1670"></a>                                {
<a name="cl-1671"></a>                                    unsigned char digit = internal::lookup_tables&lt;0&gt;::lookup_digits[static_cast&lt;unsigned char&gt;(*src)];
<a name="cl-1672"></a>                                    if (digit == 0xFF)
<a name="cl-1673"></a>                                        break;
<a name="cl-1674"></a>                                    code = code * 10 + digit;
<a name="cl-1675"></a>                                    ++src;
<a name="cl-1676"></a>                                }
<a name="cl-1677"></a>                                insert_coded_character&lt;Flags&gt;(dest, code);    // Put character in output
<a name="cl-1678"></a>                            }
<a name="cl-1679"></a>                            if (*src == Ch(';'))
<a name="cl-1680"></a>                                ++src;
<a name="cl-1681"></a>                            else
<a name="cl-1682"></a>                                RAPIDXML_PARSE_ERROR("expected ;", src);
<a name="cl-1683"></a>                            continue;
<a name="cl-1684"></a>
<a name="cl-1685"></a>                        // Something else
<a name="cl-1686"></a>                        default:
<a name="cl-1687"></a>                            // Ignore, just copy '&amp;' verbatim
<a name="cl-1688"></a>                            break;
<a name="cl-1689"></a>
<a name="cl-1690"></a>                        }
<a name="cl-1691"></a>                    }
<a name="cl-1692"></a>                }
<a name="cl-1693"></a>                
<a name="cl-1694"></a>                // If whitespace condensing is enabled
<a name="cl-1695"></a>                if (Flags &amp; parse_normalize_whitespace)
<a name="cl-1696"></a>                {
<a name="cl-1697"></a>                    // Test if condensing is needed                 
<a name="cl-1698"></a>                    if (whitespace_pred::test(*src))
<a name="cl-1699"></a>                    {
<a name="cl-1700"></a>                        *dest = Ch(' '); ++dest;    // Put single space in dest
<a name="cl-1701"></a>                        ++src;                      // Skip first whitespace char
<a name="cl-1702"></a>                        // Skip remaining whitespace chars
<a name="cl-1703"></a>                        while (whitespace_pred::test(*src))
<a name="cl-1704"></a>                            ++src;
<a name="cl-1705"></a>                        continue;
<a name="cl-1706"></a>                    }
<a name="cl-1707"></a>                }
<a name="cl-1708"></a>
<a name="cl-1709"></a>                // No replacement, only copy character
<a name="cl-1710"></a>                *dest++ = *src++;
<a name="cl-1711"></a>
<a name="cl-1712"></a>            }
<a name="cl-1713"></a>
<a name="cl-1714"></a>            // Return new end
<a name="cl-1715"></a>            text = src;
<a name="cl-1716"></a>            return dest;
<a name="cl-1717"></a>
<a name="cl-1718"></a>        }
<a name="cl-1719"></a>
<a name="cl-1720"></a>        ///////////////////////////////////////////////////////////////////////
<a name="cl-1721"></a>        // Internal parsing functions
<a name="cl-1722"></a>        
<a name="cl-1723"></a>        // Parse BOM, if any
<a name="cl-1724"></a>        template&lt;int Flags&gt;
<a name="cl-1725"></a>        void parse_bom(Ch *&amp;text)
<a name="cl-1726"></a>        {
<a name="cl-1727"></a>            // UTF-8?
<a name="cl-1728"></a>            if (static_cast&lt;unsigned char&gt;(text[0]) == 0xEF &amp;&amp; 
<a name="cl-1729"></a>                static_cast&lt;unsigned char&gt;(text[1]) == 0xBB &amp;&amp; 
<a name="cl-1730"></a>                static_cast&lt;unsigned char&gt;(text[2]) == 0xBF)
<a name="cl-1731"></a>            {
<a name="cl-1732"></a>                text += 3;      // Skup utf-8 bom
<a name="cl-1733"></a>            }
<a name="cl-1734"></a>        }
<a name="cl-1735"></a>
<a name="cl-1736"></a>        // Parse XML declaration (&lt;?xml...)
<a name="cl-1737"></a>        template&lt;int Flags&gt;
<a name="cl-1738"></a>        xml_node&lt;Ch&gt; *parse_xml_declaration(Ch *&amp;text)
<a name="cl-1739"></a>        {
<a name="cl-1740"></a>            // If parsing of declaration is disabled
<a name="cl-1741"></a>            if (!(Flags &amp; parse_declaration_node))
<a name="cl-1742"></a>            {
<a name="cl-1743"></a>                // Skip until end of declaration
<a name="cl-1744"></a>                while (text[0] != Ch('?') || text[1] != Ch('&gt;'))
<a name="cl-1745"></a>                {
<a name="cl-1746"></a>                    if (!text[0])
<a name="cl-1747"></a>                        RAPIDXML_PARSE_ERROR("unexpected end of data", text);
<a name="cl-1748"></a>                    ++text;
<a name="cl-1749"></a>                }
<a name="cl-1750"></a>                text += 2;    // Skip '?&gt;'
<a name="cl-1751"></a>                return 0;
<a name="cl-1752"></a>            }
<a name="cl-1753"></a>
<a name="cl-1754"></a>            // Create declaration
<a name="cl-1755"></a>            xml_node&lt;Ch&gt; *declaration = this-&gt;allocate_node(node_declaration);
<a name="cl-1756"></a>
<a name="cl-1757"></a>            // Skip whitespace before attributes or ?&gt;
<a name="cl-1758"></a>            skip&lt;whitespace_pred, Flags&gt;(text);
<a name="cl-1759"></a>
<a name="cl-1760"></a>            // Parse declaration attributes
<a name="cl-1761"></a>            parse_node_attributes&lt;Flags&gt;(text, declaration);
<a name="cl-1762"></a>            
<a name="cl-1763"></a>            // Skip ?&gt;
<a name="cl-1764"></a>            if (text[0] != Ch('?') || text[1] != Ch('&gt;'))
<a name="cl-1765"></a>                RAPIDXML_PARSE_ERROR("expected ?&gt;", text);
<a name="cl-1766"></a>            text += 2;
<a name="cl-1767"></a>            
<a name="cl-1768"></a>            return declaration;
<a name="cl-1769"></a>        }
<a name="cl-1770"></a>
<a name="cl-1771"></a>        // Parse XML comment (&lt;!--...)
<a name="cl-1772"></a>        template&lt;int Flags&gt;
<a name="cl-1773"></a>        xml_node&lt;Ch&gt; *parse_comment(Ch *&amp;text)
<a name="cl-1774"></a>        {
<a name="cl-1775"></a>            // If parsing of comments is disabled
<a name="cl-1776"></a>            if (!(Flags &amp; parse_comment_nodes))
<a name="cl-1777"></a>            {
<a name="cl-1778"></a>                // Skip until end of comment
<a name="cl-1779"></a>                while (text[0] != Ch('-') || text[1] != Ch('-') || text[2] != Ch('&gt;'))
<a name="cl-1780"></a>                {
<a name="cl-1781"></a>                    if (!text[0])
<a name="cl-1782"></a>                        RAPIDXML_PARSE_ERROR("unexpected end of data", text);
<a name="cl-1783"></a>                    ++text;
<a name="cl-1784"></a>                }
<a name="cl-1785"></a>                text += 3;     // Skip '--&gt;'
<a name="cl-1786"></a>                return 0;      // Do not produce comment node
<a name="cl-1787"></a>            }
<a name="cl-1788"></a>
<a name="cl-1789"></a>            // Remember value start
<a name="cl-1790"></a>            Ch *value = text;
<a name="cl-1791"></a>
<a name="cl-1792"></a>            // Skip until end of comment
<a name="cl-1793"></a>            while (text[0] != Ch('-') || text[1] != Ch('-') || text[2] != Ch('&gt;'))
<a name="cl-1794"></a>            {
<a name="cl-1795"></a>                if (!text[0])
<a name="cl-1796"></a>                    RAPIDXML_PARSE_ERROR("unexpected end of data", text);
<a name="cl-1797"></a>                ++text;
<a name="cl-1798"></a>            }
<a name="cl-1799"></a>
<a name="cl-1800"></a>            // Create comment node
<a name="cl-1801"></a>            xml_node&lt;Ch&gt; *comment = this-&gt;allocate_node(node_comment);
<a name="cl-1802"></a>            comment-&gt;value(value, text - value);
<a name="cl-1803"></a>            
<a name="cl-1804"></a>            // Place zero terminator after comment value
<a name="cl-1805"></a>            if (!(Flags &amp; parse_no_string_terminators))
<a name="cl-1806"></a>                *text = Ch('\0');
<a name="cl-1807"></a>            
<a name="cl-1808"></a>            text += 3;     // Skip '--&gt;'
<a name="cl-1809"></a>            return comment;
<a name="cl-1810"></a>        }
<a name="cl-1811"></a>
<a name="cl-1812"></a>        // Parse DOCTYPE
<a name="cl-1813"></a>        template&lt;int Flags&gt;
<a name="cl-1814"></a>        xml_node&lt;Ch&gt; *parse_doctype(Ch *&amp;text)
<a name="cl-1815"></a>        {
<a name="cl-1816"></a>            // Remember value start
<a name="cl-1817"></a>            Ch *value = text;
<a name="cl-1818"></a>
<a name="cl-1819"></a>            // Skip to &gt;
<a name="cl-1820"></a>            while (*text != Ch('&gt;'))
<a name="cl-1821"></a>            {
<a name="cl-1822"></a>                // Determine character type
<a name="cl-1823"></a>                switch (*text)
<a name="cl-1824"></a>                {
<a name="cl-1825"></a>                
<a name="cl-1826"></a>                // If '[' encountered, scan for matching ending ']' using naive algorithm with depth
<a name="cl-1827"></a>                // This works for all W3C test files except for 2 most wicked
<a name="cl-1828"></a>                case Ch('['):
<a name="cl-1829"></a>                {
<a name="cl-1830"></a>                    ++text;     // Skip '['
<a name="cl-1831"></a>                    int depth = 1;
<a name="cl-1832"></a>                    while (depth &gt; 0)
<a name="cl-1833"></a>                    {
<a name="cl-1834"></a>                        switch (*text)
<a name="cl-1835"></a>                        {
<a name="cl-1836"></a>                            case Ch('['): ++depth; break;
<a name="cl-1837"></a>                            case Ch(']'): --depth; break;
<a name="cl-1838"></a>                            case 0: RAPIDXML_PARSE_ERROR("unexpected end of data", text);
<a name="cl-1839"></a>                        }
<a name="cl-1840"></a>                        ++text;
<a name="cl-1841"></a>                    }
<a name="cl-1842"></a>                    break;
<a name="cl-1843"></a>                }
<a name="cl-1844"></a>                
<a name="cl-1845"></a>                // Error on end of text
<a name="cl-1846"></a>                case Ch('\0'):
<a name="cl-1847"></a>                    RAPIDXML_PARSE_ERROR("unexpected end of data", text);
<a name="cl-1848"></a>                
<a name="cl-1849"></a>                // Other character, skip it
<a name="cl-1850"></a>                default:
<a name="cl-1851"></a>                    ++text;
<a name="cl-1852"></a>
<a name="cl-1853"></a>                }
<a name="cl-1854"></a>            }
<a name="cl-1855"></a>            
<a name="cl-1856"></a>            // If DOCTYPE nodes enabled
<a name="cl-1857"></a>            if (Flags &amp; parse_doctype_node)
<a name="cl-1858"></a>            {
<a name="cl-1859"></a>                // Create a new doctype node
<a name="cl-1860"></a>                xml_node&lt;Ch&gt; *doctype = this-&gt;allocate_node(node_doctype);
<a name="cl-1861"></a>                doctype-&gt;value(value, text - value);
<a name="cl-1862"></a>                
<a name="cl-1863"></a>                // Place zero terminator after value
<a name="cl-1864"></a>                if (!(Flags &amp; parse_no_string_terminators))
<a name="cl-1865"></a>                    *text = Ch('\0');
<a name="cl-1866"></a>
<a name="cl-1867"></a>                text += 1;      // skip '&gt;'
<a name="cl-1868"></a>                return doctype;
<a name="cl-1869"></a>            }
<a name="cl-1870"></a>            else
<a name="cl-1871"></a>            {
<a name="cl-1872"></a>                text += 1;      // skip '&gt;'
<a name="cl-1873"></a>                return 0;
<a name="cl-1874"></a>            }
<a name="cl-1875"></a>
<a name="cl-1876"></a>        }
<a name="cl-1877"></a>
<a name="cl-1878"></a>        // Parse PI
<a name="cl-1879"></a>        template&lt;int Flags&gt;
<a name="cl-1880"></a>        xml_node&lt;Ch&gt; *parse_pi(Ch *&amp;text)
<a name="cl-1881"></a>        {
<a name="cl-1882"></a>            // If creation of PI nodes is enabled
<a name="cl-1883"></a>            if (Flags &amp; parse_pi_nodes)
<a name="cl-1884"></a>            {
<a name="cl-1885"></a>                // Create pi node
<a name="cl-1886"></a>                xml_node&lt;Ch&gt; *pi = this-&gt;allocate_node(node_pi);
<a name="cl-1887"></a>
<a name="cl-1888"></a>                // Extract PI target name
<a name="cl-1889"></a>                Ch *name = text;
<a name="cl-1890"></a>                skip&lt;node_name_pred, Flags&gt;(text);
<a name="cl-1891"></a>                if (text == name)
<a name="cl-1892"></a>                    RAPIDXML_PARSE_ERROR("expected PI target", text);
<a name="cl-1893"></a>                pi-&gt;name(name, text - name);
<a name="cl-1894"></a>                
<a name="cl-1895"></a>                // Skip whitespace between pi target and pi
<a name="cl-1896"></a>                skip&lt;whitespace_pred, Flags&gt;(text);
<a name="cl-1897"></a>
<a name="cl-1898"></a>                // Remember start of pi
<a name="cl-1899"></a>                Ch *value = text;
<a name="cl-1900"></a>                
<a name="cl-1901"></a>                // Skip to '?&gt;'
<a name="cl-1902"></a>                while (text[0] != Ch('?') || text[1] != Ch('&gt;'))
<a name="cl-1903"></a>                {
<a name="cl-1904"></a>                    if (*text == Ch('\0'))
<a name="cl-1905"></a>                        RAPIDXML_PARSE_ERROR("unexpected end of data", text);
<a name="cl-1906"></a>                    ++text;
<a name="cl-1907"></a>                }
<a name="cl-1908"></a>
<a name="cl-1909"></a>                // Set pi value (verbatim, no entity expansion or whitespace normalization)
<a name="cl-1910"></a>                pi-&gt;value(value, text - value);     
<a name="cl-1911"></a>                
<a name="cl-1912"></a>                // Place zero terminator after name and value
<a name="cl-1913"></a>                if (!(Flags &amp; parse_no_string_terminators))
<a name="cl-1914"></a>                {
<a name="cl-1915"></a>                    pi-&gt;name()[pi-&gt;name_size()] = Ch('\0');
<a name="cl-1916"></a>                    pi-&gt;value()[pi-&gt;value_size()] = Ch('\0');
<a name="cl-1917"></a>                }
<a name="cl-1918"></a>                
<a name="cl-1919"></a>                text += 2;                          // Skip '?&gt;'
<a name="cl-1920"></a>                return pi;
<a name="cl-1921"></a>            }
<a name="cl-1922"></a>            else
<a name="cl-1923"></a>            {
<a name="cl-1924"></a>                // Skip to '?&gt;'
<a name="cl-1925"></a>                while (text[0] != Ch('?') || text[1] != Ch('&gt;'))
<a name="cl-1926"></a>                {
<a name="cl-1927"></a>                    if (*text == Ch('\0'))
<a name="cl-1928"></a>                        RAPIDXML_PARSE_ERROR("unexpected end of data", text);
<a name="cl-1929"></a>                    ++text;
<a name="cl-1930"></a>                }
<a name="cl-1931"></a>                text += 2;    // Skip '?&gt;'
<a name="cl-1932"></a>                return 0;
<a name="cl-1933"></a>            }
<a name="cl-1934"></a>        }
<a name="cl-1935"></a>
<a name="cl-1936"></a>        // Parse and append data
<a name="cl-1937"></a>        // Return character that ends data.
<a name="cl-1938"></a>        // This is necessary because this character might have been overwritten by a terminating 0
<a name="cl-1939"></a>        template&lt;int Flags&gt;
<a name="cl-1940"></a>        Ch parse_and_append_data(xml_node&lt;Ch&gt; *node, Ch *&amp;text, Ch *contents_start)
<a name="cl-1941"></a>        {
<a name="cl-1942"></a>            // Backup to contents start if whitespace trimming is disabled
<a name="cl-1943"></a>            if (!(Flags &amp; parse_trim_whitespace))
<a name="cl-1944"></a>                text = contents_start;     
<a name="cl-1945"></a>            
<a name="cl-1946"></a>            // Skip until end of data
<a name="cl-1947"></a>            Ch *value = text, *end;
<a name="cl-1948"></a>            if (Flags &amp; parse_normalize_whitespace)
<a name="cl-1949"></a>                end = skip_and_expand_character_refs&lt;text_pred, text_pure_with_ws_pred, Flags&gt;(text);   
<a name="cl-1950"></a>            else
<a name="cl-1951"></a>                end = skip_and_expand_character_refs&lt;text_pred, text_pure_no_ws_pred, Flags&gt;(text);
<a name="cl-1952"></a>
<a name="cl-1953"></a>            // Trim trailing whitespace if flag is set; leading was already trimmed by whitespace skip after &gt;
<a name="cl-1954"></a>            if (Flags &amp; parse_trim_whitespace)
<a name="cl-1955"></a>            {
<a name="cl-1956"></a>                if (Flags &amp; parse_normalize_whitespace)
<a name="cl-1957"></a>                {
<a name="cl-1958"></a>                    // Whitespace is already condensed to single space characters by skipping function, so just trim 1 char off the end
<a name="cl-1959"></a>                    if (*(end - 1) == Ch(' '))
<a name="cl-1960"></a>                        --end;
<a name="cl-1961"></a>                }
<a name="cl-1962"></a>                else
<a name="cl-1963"></a>                {
<a name="cl-1964"></a>                    // Backup until non-whitespace character is found
<a name="cl-1965"></a>                    while (whitespace_pred::test(*(end - 1)))
<a name="cl-1966"></a>                        --end;
<a name="cl-1967"></a>                }
<a name="cl-1968"></a>            }
<a name="cl-1969"></a>            
<a name="cl-1970"></a>            // If characters are still left between end and value (this test is only necessary if normalization is enabled)
<a name="cl-1971"></a>            // Create new data node
<a name="cl-1972"></a>            if (!(Flags &amp; parse_no_data_nodes))
<a name="cl-1973"></a>            {
<a name="cl-1974"></a>                xml_node&lt;Ch&gt; *data = this-&gt;allocate_node(node_data);
<a name="cl-1975"></a>                data-&gt;value(value, end - value);
<a name="cl-1976"></a>                node-&gt;append_node(data);
<a name="cl-1977"></a>            }
<a name="cl-1978"></a>
<a name="cl-1979"></a>            // Add data to parent node if no data exists yet
<a name="cl-1980"></a>            if (!(Flags &amp; parse_no_element_values)) 
<a name="cl-1981"></a>                if (*node-&gt;value() == Ch('\0'))
<a name="cl-1982"></a>                    node-&gt;value(value, end - value);
<a name="cl-1983"></a>
<a name="cl-1984"></a>            // Place zero terminator after value
<a name="cl-1985"></a>            if (!(Flags &amp; parse_no_string_terminators))
<a name="cl-1986"></a>            {
<a name="cl-1987"></a>                Ch ch = *text;
<a name="cl-1988"></a>                *end = Ch('\0');
<a name="cl-1989"></a>                return ch;      // Return character that ends data; this is required because zero terminator overwritten it
<a name="cl-1990"></a>            }
<a name="cl-1991"></a>
<a name="cl-1992"></a>            // Return character that ends data
<a name="cl-1993"></a>            return *text;
<a name="cl-1994"></a>        }
<a name="cl-1995"></a>
<a name="cl-1996"></a>        // Parse CDATA
<a name="cl-1997"></a>        template&lt;int Flags&gt;
<a name="cl-1998"></a>        xml_node&lt;Ch&gt; *parse_cdata(Ch *&amp;text)
<a name="cl-1999"></a>        {
<a name="cl-2000"></a>            // If CDATA is disabled
<a name="cl-2001"></a>            if (Flags &amp; parse_no_data_nodes)
<a name="cl-2002"></a>            {
<a name="cl-2003"></a>                // Skip until end of cdata
<a name="cl-2004"></a>                while (text[0] != Ch(']') || text[1] != Ch(']') || text[2] != Ch('&gt;'))
<a name="cl-2005"></a>                {
<a name="cl-2006"></a>                    if (!text[0])
<a name="cl-2007"></a>                        RAPIDXML_PARSE_ERROR("unexpected end of data", text);
<a name="cl-2008"></a>                    ++text;
<a name="cl-2009"></a>                }
<a name="cl-2010"></a>                text += 3;      // Skip ]]&gt;
<a name="cl-2011"></a>                return 0;       // Do not produce CDATA node
<a name="cl-2012"></a>            }
<a name="cl-2013"></a>
<a name="cl-2014"></a>            // Skip until end of cdata
<a name="cl-2015"></a>            Ch *value = text;
<a name="cl-2016"></a>            while (text[0] != Ch(']') || text[1] != Ch(']') || text[2] != Ch('&gt;'))
<a name="cl-2017"></a>            {
<a name="cl-2018"></a>                if (!text[0])
<a name="cl-2019"></a>                    RAPIDXML_PARSE_ERROR("unexpected end of data", text);
<a name="cl-2020"></a>                ++text;
<a name="cl-2021"></a>            }
<a name="cl-2022"></a>
<a name="cl-2023"></a>            // Create new cdata node
<a name="cl-2024"></a>            xml_node&lt;Ch&gt; *cdata = this-&gt;allocate_node(node_cdata);
<a name="cl-2025"></a>            cdata-&gt;value(value, text - value);
<a name="cl-2026"></a>
<a name="cl-2027"></a>            // Place zero terminator after value
<a name="cl-2028"></a>            if (!(Flags &amp; parse_no_string_terminators))
<a name="cl-2029"></a>                *text = Ch('\0');
<a name="cl-2030"></a>
<a name="cl-2031"></a>            text += 3;      // Skip ]]&gt;
<a name="cl-2032"></a>            return cdata;
<a name="cl-2033"></a>        }
<a name="cl-2034"></a>        
<a name="cl-2035"></a>        // Parse element node
<a name="cl-2036"></a>        template&lt;int Flags&gt;
<a name="cl-2037"></a>        xml_node&lt;Ch&gt; *parse_element(Ch *&amp;text)
<a name="cl-2038"></a>        {
<a name="cl-2039"></a>            // Create element node
<a name="cl-2040"></a>            xml_node&lt;Ch&gt; *element = this-&gt;allocate_node(node_element);
<a name="cl-2041"></a>
<a name="cl-2042"></a>            // Extract element name
<a name="cl-2043"></a>            Ch *name = text;
<a name="cl-2044"></a>            skip&lt;node_name_pred, Flags&gt;(text);
<a name="cl-2045"></a>            if (text == name)
<a name="cl-2046"></a>                RAPIDXML_PARSE_ERROR("expected element name", text);
<a name="cl-2047"></a>            element-&gt;name(name, text - name);
<a name="cl-2048"></a>            
<a name="cl-2049"></a>            // Skip whitespace between element name and attributes or &gt;
<a name="cl-2050"></a>            skip&lt;whitespace_pred, Flags&gt;(text);
<a name="cl-2051"></a>
<a name="cl-2052"></a>            // Parse attributes, if any
<a name="cl-2053"></a>            parse_node_attributes&lt;Flags&gt;(text, element);
<a name="cl-2054"></a>
<a name="cl-2055"></a>            // Determine ending type
<a name="cl-2056"></a>            if (*text == Ch('&gt;'))
<a name="cl-2057"></a>            {
<a name="cl-2058"></a>                ++text;
<a name="cl-2059"></a>                parse_node_contents&lt;Flags&gt;(text, element);
<a name="cl-2060"></a>            }
<a name="cl-2061"></a>            else if (*text == Ch('/'))
<a name="cl-2062"></a>            {
<a name="cl-2063"></a>                ++text;
<a name="cl-2064"></a>                if (*text != Ch('&gt;'))
<a name="cl-2065"></a>                    RAPIDXML_PARSE_ERROR("expected &gt;", text);
<a name="cl-2066"></a>                ++text;
<a name="cl-2067"></a>            }
<a name="cl-2068"></a>            else
<a name="cl-2069"></a>                RAPIDXML_PARSE_ERROR("expected &gt;", text);
<a name="cl-2070"></a>
<a name="cl-2071"></a>            // Place zero terminator after name
<a name="cl-2072"></a>            if (!(Flags &amp; parse_no_string_terminators))
<a name="cl-2073"></a>                element-&gt;name()[element-&gt;name_size()] = Ch('\0');
<a name="cl-2074"></a>
<a name="cl-2075"></a>            // Return parsed element
<a name="cl-2076"></a>            return element;
<a name="cl-2077"></a>        }
<a name="cl-2078"></a>
<a name="cl-2079"></a>        // Determine node type, and parse it
<a name="cl-2080"></a>        template&lt;int Flags&gt;
<a name="cl-2081"></a>        xml_node&lt;Ch&gt; *parse_node(Ch *&amp;text)
<a name="cl-2082"></a>        {
<a name="cl-2083"></a>            // Parse proper node type
<a name="cl-2084"></a>            switch (text[0])
<a name="cl-2085"></a>            {
<a name="cl-2086"></a>
<a name="cl-2087"></a>            // &lt;...
<a name="cl-2088"></a>            default: 
<a name="cl-2089"></a>                // Parse and append element node
<a name="cl-2090"></a>                return parse_element&lt;Flags&gt;(text);
<a name="cl-2091"></a>
<a name="cl-2092"></a>            // &lt;?...
<a name="cl-2093"></a>            case Ch('?'): 
<a name="cl-2094"></a>                ++text;     // Skip ?
<a name="cl-2095"></a>                if ((text[0] == Ch('x') || text[0] == Ch('X')) &amp;&amp;
<a name="cl-2096"></a>                    (text[1] == Ch('m') || text[1] == Ch('M')) &amp;&amp; 
<a name="cl-2097"></a>                    (text[2] == Ch('l') || text[2] == Ch('L')) &amp;&amp;
<a name="cl-2098"></a>                    whitespace_pred::test(text[3]))
<a name="cl-2099"></a>                {
<a name="cl-2100"></a>                    // '&lt;?xml ' - xml declaration
<a name="cl-2101"></a>                    text += 4;      // Skip 'xml '
<a name="cl-2102"></a>                    return parse_xml_declaration&lt;Flags&gt;(text);
<a name="cl-2103"></a>                }
<a name="cl-2104"></a>                else
<a name="cl-2105"></a>                {
<a name="cl-2106"></a>                    // Parse PI
<a name="cl-2107"></a>                    return parse_pi&lt;Flags&gt;(text);
<a name="cl-2108"></a>                }
<a name="cl-2109"></a>            
<a name="cl-2110"></a>            // &lt;!...
<a name="cl-2111"></a>            case Ch('!'): 
<a name="cl-2112"></a>
<a name="cl-2113"></a>                // Parse proper subset of &lt;! node
<a name="cl-2114"></a>                switch (text[1])    
<a name="cl-2115"></a>                {
<a name="cl-2116"></a>                
<a name="cl-2117"></a>                // &lt;!-
<a name="cl-2118"></a>                case Ch('-'):
<a name="cl-2119"></a>                    if (text[2] == Ch('-'))
<a name="cl-2120"></a>                    {
<a name="cl-2121"></a>                        // '&lt;!--' - xml comment
<a name="cl-2122"></a>                        text += 3;     // Skip '!--'
<a name="cl-2123"></a>                        return parse_comment&lt;Flags&gt;(text);
<a name="cl-2124"></a>                    }
<a name="cl-2125"></a>                    break;
<a name="cl-2126"></a>
<a name="cl-2127"></a>                // &lt;![
<a name="cl-2128"></a>                case Ch('['):
<a name="cl-2129"></a>                    if (text[2] == Ch('C') &amp;&amp; text[3] == Ch('D') &amp;&amp; text[4] == Ch('A') &amp;&amp; 
<a name="cl-2130"></a>                        text[5] == Ch('T') &amp;&amp; text[6] == Ch('A') &amp;&amp; text[7] == Ch('['))
<a name="cl-2131"></a>                    {
<a name="cl-2132"></a>                        // '&lt;![CDATA[' - cdata
<a name="cl-2133"></a>                        text += 8;     // Skip '![CDATA['
<a name="cl-2134"></a>                        return parse_cdata&lt;Flags&gt;(text);
<a name="cl-2135"></a>                    }
<a name="cl-2136"></a>                    break;
<a name="cl-2137"></a>
<a name="cl-2138"></a>                // &lt;!D
<a name="cl-2139"></a>                case Ch('D'):
<a name="cl-2140"></a>                    if (text[2] == Ch('O') &amp;&amp; text[3] == Ch('C') &amp;&amp; text[4] == Ch('T') &amp;&amp; 
<a name="cl-2141"></a>                        text[5] == Ch('Y') &amp;&amp; text[6] == Ch('P') &amp;&amp; text[7] == Ch('E') &amp;&amp; 
<a name="cl-2142"></a>                        whitespace_pred::test(text[8]))
<a name="cl-2143"></a>                    {
<a name="cl-2144"></a>                        // '&lt;!DOCTYPE ' - doctype
<a name="cl-2145"></a>                        text += 9;      // skip '!DOCTYPE '
<a name="cl-2146"></a>                        return parse_doctype&lt;Flags&gt;(text);
<a name="cl-2147"></a>                    }
<a name="cl-2148"></a>
<a name="cl-2149"></a>                }   // switch
<a name="cl-2150"></a>
<a name="cl-2151"></a>                // Attempt to skip other, unrecognized node types starting with &lt;!
<a name="cl-2152"></a>                ++text;     // Skip !
<a name="cl-2153"></a>                while (*text != Ch('&gt;'))
<a name="cl-2154"></a>                {
<a name="cl-2155"></a>                    if (*text == 0)
<a name="cl-2156"></a>                        RAPIDXML_PARSE_ERROR("unexpected end of data", text);
<a name="cl-2157"></a>                    ++text;
<a name="cl-2158"></a>                }
<a name="cl-2159"></a>                ++text;     // Skip '&gt;'
<a name="cl-2160"></a>                return 0;   // No node recognized
<a name="cl-2161"></a>
<a name="cl-2162"></a>            }
<a name="cl-2163"></a>        }
<a name="cl-2164"></a>
<a name="cl-2165"></a>        // Parse contents of the node - children, data etc.
<a name="cl-2166"></a>        template&lt;int Flags&gt;
<a name="cl-2167"></a>        void parse_node_contents(Ch *&amp;text, xml_node&lt;Ch&gt; *node)
<a name="cl-2168"></a>        {
<a name="cl-2169"></a>            // For all children and text
<a name="cl-2170"></a>            while (1)
<a name="cl-2171"></a>            {
<a name="cl-2172"></a>                // Skip whitespace between &gt; and node contents
<a name="cl-2173"></a>                Ch *contents_start = text;      // Store start of node contents before whitespace is skipped
<a name="cl-2174"></a>                skip&lt;whitespace_pred, Flags&gt;(text);
<a name="cl-2175"></a>                Ch next_char = *text;
<a name="cl-2176"></a>
<a name="cl-2177"></a>            // After data nodes, instead of continuing the loop, control jumps here.
<a name="cl-2178"></a>            // This is because zero termination inside parse_and_append_data() function
<a name="cl-2179"></a>            // would wreak havoc with the above code.
<a name="cl-2180"></a>            // Also, skipping whitespace after data nodes is unnecessary.
<a name="cl-2181"></a>            after_data_node:    
<a name="cl-2182"></a>                
<a name="cl-2183"></a>                // Determine what comes next: node closing, child node, data node, or 0?
<a name="cl-2184"></a>                switch (next_char)
<a name="cl-2185"></a>                {
<a name="cl-2186"></a>                
<a name="cl-2187"></a>                // Node closing or child node
<a name="cl-2188"></a>                case Ch('&lt;'):
<a name="cl-2189"></a>                    if (text[1] == Ch('/'))
<a name="cl-2190"></a>                    {
<a name="cl-2191"></a>                        // Node closing
<a name="cl-2192"></a>                        text += 2;      // Skip '&lt;/'
<a name="cl-2193"></a>                        if (Flags &amp; parse_validate_closing_tags)
<a name="cl-2194"></a>                        {
<a name="cl-2195"></a>                            // Skip and validate closing tag name
<a name="cl-2196"></a>                            Ch *closing_name = text;
<a name="cl-2197"></a>                            skip&lt;node_name_pred, Flags&gt;(text);
<a name="cl-2198"></a>                            if (!internal::compare(node-&gt;name(), node-&gt;name_size(), closing_name, text - closing_name, true))
<a name="cl-2199"></a>                                RAPIDXML_PARSE_ERROR("invalid closing tag name", text);
<a name="cl-2200"></a>                        }
<a name="cl-2201"></a>                        else
<a name="cl-2202"></a>                        {
<a name="cl-2203"></a>                            // No validation, just skip name
<a name="cl-2204"></a>                            skip&lt;node_name_pred, Flags&gt;(text);
<a name="cl-2205"></a>                        }
<a name="cl-2206"></a>                        // Skip remaining whitespace after node name
<a name="cl-2207"></a>                        skip&lt;whitespace_pred, Flags&gt;(text);
<a name="cl-2208"></a>                        if (*text != Ch('&gt;'))
<a name="cl-2209"></a>                            RAPIDXML_PARSE_ERROR("expected &gt;", text);
<a name="cl-2210"></a>                        ++text;     // Skip '&gt;'
<a name="cl-2211"></a>                        return;     // Node closed, finished parsing contents
<a name="cl-2212"></a>                    }
<a name="cl-2213"></a>                    else
<a name="cl-2214"></a>                    {
<a name="cl-2215"></a>                        // Child node
<a name="cl-2216"></a>                        ++text;     // Skip '&lt;'
<a name="cl-2217"></a>                        if (xml_node&lt;Ch&gt; *child = parse_node&lt;Flags&gt;(text))
<a name="cl-2218"></a>                            node-&gt;append_node(child);
<a name="cl-2219"></a>                    }
<a name="cl-2220"></a>                    break;
<a name="cl-2221"></a>
<a name="cl-2222"></a>                // End of data - error
<a name="cl-2223"></a>                case Ch('\0'):
<a name="cl-2224"></a>                    RAPIDXML_PARSE_ERROR("unexpected end of data", text);
<a name="cl-2225"></a>
<a name="cl-2226"></a>                // Data node
<a name="cl-2227"></a>                default:
<a name="cl-2228"></a>                    next_char = parse_and_append_data&lt;Flags&gt;(node, text, contents_start);
<a name="cl-2229"></a>                    goto after_data_node;   // Bypass regular processing after data nodes
<a name="cl-2230"></a>
<a name="cl-2231"></a>                }
<a name="cl-2232"></a>            }
<a name="cl-2233"></a>        }
<a name="cl-2234"></a>        
<a name="cl-2235"></a>        // Parse XML attributes of the node
<a name="cl-2236"></a>        template&lt;int Flags&gt;
<a name="cl-2237"></a>        void parse_node_attributes(Ch *&amp;text, xml_node&lt;Ch&gt; *node)
<a name="cl-2238"></a>        {
<a name="cl-2239"></a>            // For all attributes 
<a name="cl-2240"></a>            while (attribute_name_pred::test(*text))
<a name="cl-2241"></a>            {
<a name="cl-2242"></a>                // Extract attribute name
<a name="cl-2243"></a>                Ch *name = text;
<a name="cl-2244"></a>                ++text;     // Skip first character of attribute name
<a name="cl-2245"></a>                skip&lt;attribute_name_pred, Flags&gt;(text);
<a name="cl-2246"></a>                if (text == name)
<a name="cl-2247"></a>                    RAPIDXML_PARSE_ERROR("expected attribute name", name);
<a name="cl-2248"></a>
<a name="cl-2249"></a>                // Create new attribute
<a name="cl-2250"></a>                xml_attribute&lt;Ch&gt; *attribute = this-&gt;allocate_attribute();
<a name="cl-2251"></a>                attribute-&gt;name(name, text - name);
<a name="cl-2252"></a>                node-&gt;append_attribute(attribute);
<a name="cl-2253"></a>
<a name="cl-2254"></a>                // Skip whitespace after attribute name
<a name="cl-2255"></a>                skip&lt;whitespace_pred, Flags&gt;(text);
<a name="cl-2256"></a>
<a name="cl-2257"></a>                // Skip =
<a name="cl-2258"></a>                if (*text != Ch('='))
<a name="cl-2259"></a>                    RAPIDXML_PARSE_ERROR("expected =", text);
<a name="cl-2260"></a>                ++text;
<a name="cl-2261"></a>
<a name="cl-2262"></a>                // Add terminating zero after name
<a name="cl-2263"></a>                if (!(Flags &amp; parse_no_string_terminators))
<a name="cl-2264"></a>                    attribute-&gt;name()[attribute-&gt;name_size()] = 0;
<a name="cl-2265"></a>
<a name="cl-2266"></a>                // Skip whitespace after =
<a name="cl-2267"></a>                skip&lt;whitespace_pred, Flags&gt;(text);
<a name="cl-2268"></a>
<a name="cl-2269"></a>                // Skip quote and remember if it was ' or "
<a name="cl-2270"></a>                Ch quote = *text;
<a name="cl-2271"></a>                if (quote != Ch('\'') &amp;&amp; quote != Ch('"'))
<a name="cl-2272"></a>                    RAPIDXML_PARSE_ERROR("expected ' or \"", text);
<a name="cl-2273"></a>                ++text;
<a name="cl-2274"></a>
<a name="cl-2275"></a>                // Extract attribute value and expand char refs in it
<a name="cl-2276"></a>                Ch *value = text, *end;
<a name="cl-2277"></a>                const int AttFlags = Flags &amp; ~parse_normalize_whitespace;   // No whitespace normalization in attributes
<a name="cl-2278"></a>                if (quote == Ch('\''))
<a name="cl-2279"></a>                    end = skip_and_expand_character_refs&lt;attribute_value_pred&lt;Ch('\'')&gt;, attribute_value_pure_pred&lt;Ch('\'')&gt;, AttFlags&gt;(text);
<a name="cl-2280"></a>                else
<a name="cl-2281"></a>                    end = skip_and_expand_character_refs&lt;attribute_value_pred&lt;Ch('"')&gt;, attribute_value_pure_pred&lt;Ch('"')&gt;, AttFlags&gt;(text);
<a name="cl-2282"></a>                
<a name="cl-2283"></a>                // Set attribute value
<a name="cl-2284"></a>                attribute-&gt;value(value, end - value);
<a name="cl-2285"></a>                
<a name="cl-2286"></a>                // Make sure that end quote is present
<a name="cl-2287"></a>                if (*text != quote)
<a name="cl-2288"></a>                    RAPIDXML_PARSE_ERROR("expected ' or \"", text);
<a name="cl-2289"></a>                ++text;     // Skip quote
<a name="cl-2290"></a>
<a name="cl-2291"></a>                // Add terminating zero after value
<a name="cl-2292"></a>                if (!(Flags &amp; parse_no_string_terminators))
<a name="cl-2293"></a>                    attribute-&gt;value()[attribute-&gt;value_size()] = 0;
<a name="cl-2294"></a>
<a name="cl-2295"></a>                // Skip whitespace after attribute value
<a name="cl-2296"></a>                skip&lt;whitespace_pred, Flags&gt;(text);
<a name="cl-2297"></a>            }
<a name="cl-2298"></a>        }
<a name="cl-2299"></a>
<a name="cl-2300"></a>    };
<a name="cl-2301"></a>
<a name="cl-2302"></a>    //! \cond internal
<a name="cl-2303"></a>    namespace internal
<a name="cl-2304"></a>    {
<a name="cl-2305"></a>
<a name="cl-2306"></a>        // Whitespace (space \n \r \t)
<a name="cl-2307"></a>        template&lt;int Dummy&gt;
<a name="cl-2308"></a>        const unsigned char lookup_tables&lt;Dummy&gt;::lookup_whitespace[256] = 
<a name="cl-2309"></a>        {
<a name="cl-2310"></a>          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
<a name="cl-2311"></a>             0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  1,  0,  0,  // 0
<a name="cl-2312"></a>             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 1
<a name="cl-2313"></a>             1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 2
<a name="cl-2314"></a>             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 3
<a name="cl-2315"></a>             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 4
<a name="cl-2316"></a>             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 5
<a name="cl-2317"></a>             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 6
<a name="cl-2318"></a>             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 7
<a name="cl-2319"></a>             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 8
<a name="cl-2320"></a>             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 9
<a name="cl-2321"></a>             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // A
<a name="cl-2322"></a>             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // B
<a name="cl-2323"></a>             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // C
<a name="cl-2324"></a>             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // D
<a name="cl-2325"></a>             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // E
<a name="cl-2326"></a>             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0   // F
<a name="cl-2327"></a>        };
<a name="cl-2328"></a>
<a name="cl-2329"></a>        // Node name (anything but space \n \r \t / &gt; ? \0)
<a name="cl-2330"></a>        template&lt;int Dummy&gt;
<a name="cl-2331"></a>        const unsigned char lookup_tables&lt;Dummy&gt;::lookup_node_name[256] = 
<a name="cl-2332"></a>        {
<a name="cl-2333"></a>          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
<a name="cl-2334"></a>             0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  1,  1,  0,  1,  1,  // 0
<a name="cl-2335"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
<a name="cl-2336"></a>             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  // 2
<a name="cl-2337"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  // 3
<a name="cl-2338"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
<a name="cl-2339"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
<a name="cl-2340"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
<a name="cl-2341"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
<a name="cl-2342"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
<a name="cl-2343"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
<a name="cl-2344"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
<a name="cl-2345"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
<a name="cl-2346"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
<a name="cl-2347"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
<a name="cl-2348"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
<a name="cl-2349"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
<a name="cl-2350"></a>        };
<a name="cl-2351"></a>
<a name="cl-2352"></a>        // Text (i.e. PCDATA) (anything but &lt; \0)
<a name="cl-2353"></a>        template&lt;int Dummy&gt;
<a name="cl-2354"></a>        const unsigned char lookup_tables&lt;Dummy&gt;::lookup_text[256] = 
<a name="cl-2355"></a>        {
<a name="cl-2356"></a>          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
<a name="cl-2357"></a>             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 0
<a name="cl-2358"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
<a name="cl-2359"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 2
<a name="cl-2360"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  // 3
<a name="cl-2361"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
<a name="cl-2362"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
<a name="cl-2363"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
<a name="cl-2364"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
<a name="cl-2365"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
<a name="cl-2366"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
<a name="cl-2367"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
<a name="cl-2368"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
<a name="cl-2369"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
<a name="cl-2370"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
<a name="cl-2371"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
<a name="cl-2372"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
<a name="cl-2373"></a>        };
<a name="cl-2374"></a>
<a name="cl-2375"></a>        // Text (i.e. PCDATA) that does not require processing when ws normalization is disabled 
<a name="cl-2376"></a>        // (anything but &lt; \0 &amp;)
<a name="cl-2377"></a>        template&lt;int Dummy&gt;
<a name="cl-2378"></a>        const unsigned char lookup_tables&lt;Dummy&gt;::lookup_text_pure_no_ws[256] = 
<a name="cl-2379"></a>        {
<a name="cl-2380"></a>          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
<a name="cl-2381"></a>             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 0
<a name="cl-2382"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
<a name="cl-2383"></a>             1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 2
<a name="cl-2384"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  // 3
<a name="cl-2385"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
<a name="cl-2386"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
<a name="cl-2387"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
<a name="cl-2388"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
<a name="cl-2389"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
<a name="cl-2390"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
<a name="cl-2391"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
<a name="cl-2392"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
<a name="cl-2393"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
<a name="cl-2394"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
<a name="cl-2395"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
<a name="cl-2396"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
<a name="cl-2397"></a>        };
<a name="cl-2398"></a>
<a name="cl-2399"></a>        // Text (i.e. PCDATA) that does not require processing when ws normalizationis is enabled
<a name="cl-2400"></a>        // (anything but &lt; \0 &amp; space \n \r \t)
<a name="cl-2401"></a>        template&lt;int Dummy&gt;
<a name="cl-2402"></a>        const unsigned char lookup_tables&lt;Dummy&gt;::lookup_text_pure_with_ws[256] = 
<a name="cl-2403"></a>        {
<a name="cl-2404"></a>          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
<a name="cl-2405"></a>             0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  1,  1,  0,  1,  1,  // 0
<a name="cl-2406"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
<a name="cl-2407"></a>             0,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 2
<a name="cl-2408"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  // 3
<a name="cl-2409"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
<a name="cl-2410"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
<a name="cl-2411"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
<a name="cl-2412"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
<a name="cl-2413"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
<a name="cl-2414"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
<a name="cl-2415"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
<a name="cl-2416"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
<a name="cl-2417"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
<a name="cl-2418"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
<a name="cl-2419"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
<a name="cl-2420"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
<a name="cl-2421"></a>        };
<a name="cl-2422"></a>
<a name="cl-2423"></a>        // Attribute name (anything but space \n \r \t / &lt; &gt; = ? ! \0)
<a name="cl-2424"></a>        template&lt;int Dummy&gt;
<a name="cl-2425"></a>        const unsigned char lookup_tables&lt;Dummy&gt;::lookup_attribute_name[256] = 
<a name="cl-2426"></a>        {
<a name="cl-2427"></a>          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
<a name="cl-2428"></a>             0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  1,  1,  0,  1,  1,  // 0
<a name="cl-2429"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
<a name="cl-2430"></a>             0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  // 2
<a name="cl-2431"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  // 3
<a name="cl-2432"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
<a name="cl-2433"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
<a name="cl-2434"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
<a name="cl-2435"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
<a name="cl-2436"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
<a name="cl-2437"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
<a name="cl-2438"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
<a name="cl-2439"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
<a name="cl-2440"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
<a name="cl-2441"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
<a name="cl-2442"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
<a name="cl-2443"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
<a name="cl-2444"></a>        };
<a name="cl-2445"></a>
<a name="cl-2446"></a>        // Attribute data with single quote (anything but ' \0)
<a name="cl-2447"></a>        template&lt;int Dummy&gt;
<a name="cl-2448"></a>        const unsigned char lookup_tables&lt;Dummy&gt;::lookup_attribute_data_1[256] = 
<a name="cl-2449"></a>        {
<a name="cl-2450"></a>          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
<a name="cl-2451"></a>             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 0
<a name="cl-2452"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
<a name="cl-2453"></a>             1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  // 2
<a name="cl-2454"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 3
<a name="cl-2455"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
<a name="cl-2456"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
<a name="cl-2457"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
<a name="cl-2458"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
<a name="cl-2459"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
<a name="cl-2460"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
<a name="cl-2461"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
<a name="cl-2462"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
<a name="cl-2463"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
<a name="cl-2464"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
<a name="cl-2465"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
<a name="cl-2466"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
<a name="cl-2467"></a>        };
<a name="cl-2468"></a>
<a name="cl-2469"></a>        // Attribute data with single quote that does not require processing (anything but ' \0 &amp;)
<a name="cl-2470"></a>        template&lt;int Dummy&gt;
<a name="cl-2471"></a>        const unsigned char lookup_tables&lt;Dummy&gt;::lookup_attribute_data_1_pure[256] = 
<a name="cl-2472"></a>        {
<a name="cl-2473"></a>          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
<a name="cl-2474"></a>             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 0
<a name="cl-2475"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
<a name="cl-2476"></a>             1,  1,  1,  1,  1,  1,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  // 2
<a name="cl-2477"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 3
<a name="cl-2478"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
<a name="cl-2479"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
<a name="cl-2480"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
<a name="cl-2481"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
<a name="cl-2482"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
<a name="cl-2483"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
<a name="cl-2484"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
<a name="cl-2485"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
<a name="cl-2486"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
<a name="cl-2487"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
<a name="cl-2488"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
<a name="cl-2489"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
<a name="cl-2490"></a>        };
<a name="cl-2491"></a>
<a name="cl-2492"></a>        // Attribute data with double quote (anything but " \0)
<a name="cl-2493"></a>        template&lt;int Dummy&gt;
<a name="cl-2494"></a>        const unsigned char lookup_tables&lt;Dummy&gt;::lookup_attribute_data_2[256] = 
<a name="cl-2495"></a>        {
<a name="cl-2496"></a>          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
<a name="cl-2497"></a>             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 0
<a name="cl-2498"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
<a name="cl-2499"></a>             1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 2
<a name="cl-2500"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 3
<a name="cl-2501"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
<a name="cl-2502"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
<a name="cl-2503"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
<a name="cl-2504"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
<a name="cl-2505"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
<a name="cl-2506"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
<a name="cl-2507"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
<a name="cl-2508"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
<a name="cl-2509"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
<a name="cl-2510"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
<a name="cl-2511"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
<a name="cl-2512"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
<a name="cl-2513"></a>        };
<a name="cl-2514"></a>
<a name="cl-2515"></a>        // Attribute data with double quote that does not require processing (anything but " \0 &amp;)
<a name="cl-2516"></a>        template&lt;int Dummy&gt;
<a name="cl-2517"></a>        const unsigned char lookup_tables&lt;Dummy&gt;::lookup_attribute_data_2_pure[256] = 
<a name="cl-2518"></a>        {
<a name="cl-2519"></a>          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
<a name="cl-2520"></a>             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 0
<a name="cl-2521"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
<a name="cl-2522"></a>             1,  1,  0,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 2
<a name="cl-2523"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 3
<a name="cl-2524"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
<a name="cl-2525"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
<a name="cl-2526"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
<a name="cl-2527"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
<a name="cl-2528"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
<a name="cl-2529"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
<a name="cl-2530"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
<a name="cl-2531"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
<a name="cl-2532"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
<a name="cl-2533"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
<a name="cl-2534"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
<a name="cl-2535"></a>             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
<a name="cl-2536"></a>        };
<a name="cl-2537"></a>
<a name="cl-2538"></a>        // Digits (dec and hex, 255 denotes end of numeric character reference)
<a name="cl-2539"></a>        template&lt;int Dummy&gt;
<a name="cl-2540"></a>        const unsigned char lookup_tables&lt;Dummy&gt;::lookup_digits[256] = 
<a name="cl-2541"></a>        {
<a name="cl-2542"></a>          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
<a name="cl-2543"></a>           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 0
<a name="cl-2544"></a>           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 1
<a name="cl-2545"></a>           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 2
<a name="cl-2546"></a>             0,  1,  2,  3,  4,  5,  6,  7,  8,  9,255,255,255,255,255,255,  // 3
<a name="cl-2547"></a>           255, 10, 11, 12, 13, 14, 15,255,255,255,255,255,255,255,255,255,  // 4
<a name="cl-2548"></a>           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 5
<a name="cl-2549"></a>           255, 10, 11, 12, 13, 14, 15,255,255,255,255,255,255,255,255,255,  // 6
<a name="cl-2550"></a>           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 7
<a name="cl-2551"></a>           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 8
<a name="cl-2552"></a>           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 9
<a name="cl-2553"></a>           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // A
<a name="cl-2554"></a>           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // B
<a name="cl-2555"></a>           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // C
<a name="cl-2556"></a>           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // D
<a name="cl-2557"></a>           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // E
<a name="cl-2558"></a>           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255   // F
<a name="cl-2559"></a>        };
<a name="cl-2560"></a>    
<a name="cl-2561"></a>        // Upper case conversion
<a name="cl-2562"></a>        template&lt;int Dummy&gt;
<a name="cl-2563"></a>        const unsigned char lookup_tables&lt;Dummy&gt;::lookup_upcase[256] = 
<a name="cl-2564"></a>        {
<a name="cl-2565"></a>          // 0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  A   B   C   D   E   F
<a name="cl-2566"></a>           0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15,   // 0
<a name="cl-2567"></a>           16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,   // 1
<a name="cl-2568"></a>           32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,   // 2
<a name="cl-2569"></a>           48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,   // 3
<a name="cl-2570"></a>           64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,   // 4
<a name="cl-2571"></a>           80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,   // 5
<a name="cl-2572"></a>           96, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,   // 6
<a name="cl-2573"></a>           80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 123,124,125,126,127,  // 7
<a name="cl-2574"></a>           128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,  // 8
<a name="cl-2575"></a>           144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,  // 9
<a name="cl-2576"></a>           160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,  // A
<a name="cl-2577"></a>           176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,  // B
<a name="cl-2578"></a>           192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,  // C
<a name="cl-2579"></a>           208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,  // D
<a name="cl-2580"></a>           224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,  // E
<a name="cl-2581"></a>           240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255   // F
<a name="cl-2582"></a>        };
<a name="cl-2583"></a>    }
<a name="cl-2584"></a>    //! \endcond
<a name="cl-2585"></a>
<a name="cl-2586"></a>}
<a name="cl-2587"></a>
<a name="cl-2588"></a>// Undefine internal macros
<a name="cl-2589"></a>#undef RAPIDXML_PARSE_ERROR
<a name="cl-2590"></a>
<a name="cl-2591"></a>// On MSVC, restore warnings state
<a name="cl-2592"></a>#ifdef _MSC_VER
<a name="cl-2593"></a>    #pragma warning(pop)
<a name="cl-2594"></a>#endif
<a name="cl-2595"></a>
<a name="cl-2596"></a>#endif
</pre></div></td></tr></table>

          </div>
        
      
    
  


  <script id="source-changeset" type="text/html">
  

<a href="/spacegaier/advancedogreframework/src/[[raw_node]]/AdvancedOgreFramework/rapidxml.hpp?at=default"
   class="[[#selected]]highlight[[/selected]]"
   data-hash="[[node]]">
  [[#author.username]]
    <img class="avatar avatar16" src="[[author.avatar]]"/>
    <span class="author" title="[[raw_author]]">[[author.display_name]]</span>
  [[/author.username]]
  [[^author.username]]
    <img class="avatar avatar16" src="https://d3oaxc4q5k2d6q.cloudfront.net/m/9e262ba34f96/img/default_avatar/16/user_blue.png"/>
    <span class="author unmapped" title="[[raw_author]]">[[author]]</span>
  [[/author.username]]
  <time datetime="[[utctimestamp]]" data-title="true">[[utctimestamp]]</time>
  <span class="message">[[message]]</span>
</a>

</script>
  <script id="embed-template" type="text/html">
  

<form class="aui embed">
  <label for="embed-code">Embed this source in another page:</label>
  <input type="text" readonly="true" value="&lt;script src=&quot;[[url]]&quot;&gt;&lt;/script&gt;" id="embed-code">
</form>

</script>


<div class="mask"></div>



  <script id="branch-dialog-template" type="text/html">
  

<div class="tabbed-filter-widget branch-dialog">
  <div class="tabbed-filter">
    <input placeholder="Filter branches" class="filter-box" autosave="branch-dropdown-570991" type="text">
    [[^ignoreTags]]
      <div class="aui-tabs horizontal-tabs aui-tabs-disabled filter-tabs">
        <ul class="tabs-menu">
          <li class="menu-item active-tab"><a href="#branches">Branches</a></li>
          <li class="menu-item"><a href="#tags">Tags</a></li>
        </ul>
      </div>
    [[/ignoreTags]]
  </div>
  
    <div class="tab-pane active-pane" id="branches" data-filter-placeholder="Filter branches">
      <ol class="filter-list">
        <li class="empty-msg">No matching branches</li>
        [[#branches]]
          [[#hasMultipleHeads]]
            [[#heads]]
              <li class="comprev filter-item">
                <a href="/spacegaier/advancedogreframework/src/[[changeset]]/AdvancedOgreFramework/rapidxml.hpp?at=[[safeName]]"
                   title="[[name]]">
                  [[name]] ([[shortChangeset]])
                </a>
              </li>
            [[/heads]]
          [[/hasMultipleHeads]]
          [[^hasMultipleHeads]]
            <li class="comprev filter-item">
              <a href="/spacegaier/advancedogreframework/src/[[changeset]]/AdvancedOgreFramework/rapidxml.hpp?at=[[safeName]]" title="[[name]]">
                [[name]]
              </a>
            </li>
          [[/hasMultipleHeads]]
        [[/branches]]
      </ol>
    </div>
    <div class="tab-pane" id="tags" data-filter-placeholder="Filter tags">
      <ol class="filter-list">
        <li class="empty-msg">No matching tags</li>
        [[#tags]]
          <li class="comprev filter-item">
            <a href="/spacegaier/advancedogreframework/src/[[changeset]]/AdvancedOgreFramework/rapidxml.hpp?at=[[safeName]]" title="[[name]]">
              [[name]]
            </a>
          </li>
        [[/tags]]
      </ol>
    </div>
  
</div>

</script>



  </div>

  </div>
  

<form id="file-search-form" action="#"
  
  data-revision="d24a1662021a2ca899990513e45bc2477cbd9339"
  data-branch="default">
  <input type="text" id="file-search-query" class="loading">
  <div id="filtered-files"></div>
  <div class="tip"><em>Tip:</em> Filter by directory path e.g. <strong>/media app.js</strong> to search for public<strong>/media/app.js</strong>.</div>
  <div class="tip"><em>Tip:</em> Use camelCasing e.g. <strong>ProjME</strong> to search for <strong>ProjectModifiedE</strong>vent.java.</div>
  <div class="tip"><em>Tip:</em> Filter by extension type e.g. <strong>/repo .js</strong> to search for all <strong>.js</strong> files in the <strong>/repo</strong> directory.</div>
  <div class="tip"><em>Tip:</em> Separate your search with spaces e.g. <strong>/ssh pom.xml</strong> to search for src<strong>/ssh/pom.xml</strong>.</div>
  <div class="tip"><em>Tip:</em> Use  and  arrow keys to navigate and <strong>return</strong> to view the file.</div>
  <div class="tip mod-osx"><em>Tip:</em> You can also navigate files with <strong>Ctrl+j</strong> <em>(next)</em> and <strong>Ctrl+k</strong> <em>(previous)</em> and view the file with <strong>Ctrl+o</strong>.</div>
  <div class="tip mod-win"><em>Tip:</em> You can also navigate files with <strong>Alt+j</strong> <em>(next)</em> and <strong>Alt+k</strong> <em>(previous)</em> and view the file with <strong>Alt+o</strong>.</div>
  <script id="filtered-files-template" type="text/html">
  

<table class="aui bb-list">
  <thead>
    <tr class="assistive">
      <th class="name">Filename</th>
    </tr>
  </thead>
  <tbody>
    [[#files]]
    <tr class="iterable-item">
      <td class="name [[#isDirectory]]directory[[/isDirectory]]">
        <a href="/spacegaier/advancedogreframework/src/[[node]]/[[name]][[#branch]]?at=[[branch]][[/branch]]"
           title="[[name]]" class="execute" tabindex="-1">
          [[&highlightedName]]
        </a>
      </td>
    </tr>
    [[/files]]
  </tbody>
</table>

</script>
</form>


    </div>
  </div>
  <footer id="footer" role="contentinfo">
    <section class="footer-body">
      <ul>
        <li><a href="http://blog.bitbucket.org">Blog</a></li>
        <li><a href="//bitbucket.org/site/master/issues/new">Report a bug</a></li>
        <li><a href="/support">Support</a></li>
        <li><a href="http://confluence.atlassian.com/display/BITBUCKET">Documentation</a></li>
        <li><a href="http://confluence.atlassian.com/x/IYBGDQ">API</a></li>
        <li><a href="http://groups.google.com/group/bitbucket-users">Forum</a></li>
        <li><a href="http://status.bitbucket.org/">Server status</a></li>
        <li><a href="http://www.atlassian.com/hosted/terms.jsp">Terms of service</a></li>
        <li><a href="http://www.atlassian.com/about/privacy.jsp">Privacy policy</a></li>
      </ul>
      <ul>
        
        <li><a href="http://git-scm.com/">Git 1.7.10.3</a></li>
        <li><a href="http://mercurial.selenic.com/">Mercurial 2.2.2</a></li>
        <li><a href="https://www.djangoproject.com/">Django 1.3.1</a></li>
        <li><a href="http://www.python.org/">Python 2.7.3</a></li>
        <li><a href="#">1a0ea496d75b / 9e262ba34f96 @ bitbucket01</a></li>
      </ul>
    </section>
  </footer>
</div>

<script type="text/javascript" src="https://d3oaxc4q5k2d6q.cloudfront.net/m/9e262ba34f96/compressed/js/41c4c0a4ebcc.js"></script>

<!-- This script exists purely for the benefit of our selenium tests -->
<script>
  setTimeout(function () {
    BB.JsLoaded = true;
  }, 3000);
</script>



<script>
  (function (window) {
    // Base URL to use for non-CNAME URLs.
    BB.baseUrl = 'https://bitbucket.org';

    BB.images = {
      invitation: 'https://d3oaxc4q5k2d6q.cloudfront.net/m/9e262ba34f96/img/icons/fugue/card_address.png',
      noAvatar: 'https://d3oaxc4q5k2d6q.cloudfront.net/m/9e262ba34f96/img/default_avatar/16/user_blue.png'
    };
    BB.user = {"isKbdShortcutsEnabled": true, "isSshEnabled": false, "isAuthenticated": false};
    BB.repo || (BB.repo = {});
    
      BB.repo.id = 570991;
      BB.repo.scm = 'hg';
      BB.repo.readonly = false;
      
      
        BB.repo.language = 'c++';
        BB.repo.pygmentsLanguage = 'c++';
      
      
        BB.repo.slug = 'advancedogreframework';
      
      
        BB.repo.owner = {};
        BB.repo.owner.username = 'spacegaier';
        BB.repo.owner.is_team = false;
      
      
      // Coerce `BB.repo` to a string to get
      // "davidchambers/mango" or whatever.
      BB.repo.toString = function () {
        return BB.cname ? this.slug : '{owner.username}/{slug}'.format(this);
      }
      
        BB.changeset = 'd24a1662021a2ca899990513e45bc2477cbd9339'
      
      
    
    window.setInterval(BB.localize, 60 * 1000);
    $(document).on('ready pjax:end', function () { BB.localize(); });
  })(window);
</script>


<script>
    // Bitbucket Google Analytics
    // NOTE: these will not fire in development. In debug mode it just logs them to console.
    (function (window) {
        // Track the main pageview to the Bitbucket GA account.
        BB.gaqPush(['_trackPageview']);
        // Track the main pageview to the Atlassian GA account.
        BB.gaqPush(['atl._trackPageview']);

        


        

        // Include GA commands from sub-templates
        

        (function () {
            var ga = document.createElement('script');
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            ga.setAttribute('async', 'true');
            document.documentElement.firstChild.appendChild(ga);
        }());
    })(window);
</script>



<script type="text/javascript">if(!NREUMQ.f){NREUMQ.f=function(){NREUMQ.push(["load",new Date().getTime()]);var e=document.createElement("script");e.type="text/javascript";e.src=(("http:"===document.location.protocol)?"http:":"https:")+"//"+"d1ros97qkrwjf5.cloudfront.net/42/eum/rum.js";document.body.appendChild(e);if(NREUMQ.a)NREUMQ.a();};NREUMQ.a=window.onload;window.onload=NREUMQ.f;};NREUMQ.push(["nrfj","beacon-1.newrelic.com","7d4a9813d0","295788","MgMDYhcHDUJVVEIKWAtJJ0MLBRdYW1kZAV4RBBRVDgMXH1VHRhAZFwMRWVdIFVhRQEVZUQwKBFQXCRRCUQ==",0,236,new Date().getTime(),"","","","",""]);</script></body>
</html>
